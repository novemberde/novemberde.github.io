<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Legacy android application, Kotlin 적용기 | Novemberde's Blog</title>
<meta name=keywords content="java,legacy,kotlin,android,안드로이드,자바,코틀린,공존">
<meta name=description content="Summary  안드로이드 개발 언어의 트렌드는 바뀌었다. 최근 Google I/O에서 나오는 샘플 코드들은 Kotlin으로 짜여져 있었다. 또한 안드로이드 개발 컨퍼런스의 주제는 Kotlin으로 개발한 경험담이 주를 이루고 있다.
Kotlin으로 개발하는 것이 낫다는 내용을 많이 보기도 하였고 개발에 욕심이 있다보니, 이번에는 기존에 JAVA로 개발되어 있던 코드에 Kotlin을 적용하여 새로 구성하거나 변경하는 클래스를 Kotlin으로 구성해보았다.
다음은 이런 과정을 거치면서 느낀 장점과 단점에 대한 고찰이다.
고찰  Kotlin의 장점을 느끼기 전에는 치명적인 단점(?)과 싸워야만 한다.">
<meta name=author content>
<link rel=canonical href=https://novemberde.github.io/post/2018/05/28/kotlin/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.9f1d947375927e9847272b1f4e9be81336f539e513bf04d52cade31f81cad1af.css integrity="sha256-nx2Uc3WSfphHJysfTpvoEzb1OeUTvwTVLK3jH4HK0a8=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://novemberde.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://novemberde.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://novemberde.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://novemberde.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://novemberde.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-97433460-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Legacy android application, Kotlin 적용기">
<meta property="og:description" content="Summary  안드로이드 개발 언어의 트렌드는 바뀌었다. 최근 Google I/O에서 나오는 샘플 코드들은 Kotlin으로 짜여져 있었다. 또한 안드로이드 개발 컨퍼런스의 주제는 Kotlin으로 개발한 경험담이 주를 이루고 있다.
Kotlin으로 개발하는 것이 낫다는 내용을 많이 보기도 하였고 개발에 욕심이 있다보니, 이번에는 기존에 JAVA로 개발되어 있던 코드에 Kotlin을 적용하여 새로 구성하거나 변경하는 클래스를 Kotlin으로 구성해보았다.
다음은 이런 과정을 거치면서 느낀 장점과 단점에 대한 고찰이다.
고찰  Kotlin의 장점을 느끼기 전에는 치명적인 단점(?)과 싸워야만 한다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://novemberde.github.io/post/2018/05/28/kotlin/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2018-05-28T11:30:03+00:00">
<meta property="article:modified_time" content="2018-05-28T11:30:03+00:00"><meta property="og:site_name" content="Novemberde dev logs">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Legacy android application, Kotlin 적용기">
<meta name=twitter:description content="Summary  안드로이드 개발 언어의 트렌드는 바뀌었다. 최근 Google I/O에서 나오는 샘플 코드들은 Kotlin으로 짜여져 있었다. 또한 안드로이드 개발 컨퍼런스의 주제는 Kotlin으로 개발한 경험담이 주를 이루고 있다.
Kotlin으로 개발하는 것이 낫다는 내용을 많이 보기도 하였고 개발에 욕심이 있다보니, 이번에는 기존에 JAVA로 개발되어 있던 코드에 Kotlin을 적용하여 새로 구성하거나 변경하는 클래스를 Kotlin으로 구성해보았다.
다음은 이런 과정을 거치면서 느낀 장점과 단점에 대한 고찰이다.
고찰  Kotlin의 장점을 느끼기 전에는 치명적인 단점(?)과 싸워야만 한다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://novemberde.github.io/post/"},{"@type":"ListItem","position":2,"name":"Legacy android application, Kotlin 적용기","item":"https://novemberde.github.io/post/2018/05/28/kotlin/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Legacy android application, Kotlin 적용기","name":"Legacy android application, Kotlin 적용기","description":"Summary  안드로이드 개발 언어의 트렌드는 바뀌었다. 최근 Google I/O에서 나오는 샘플 코드들은 Kotlin으로 짜여져 있었다. 또한 안드로이드 개발 컨퍼런스의 주제는 Kotlin으로 개발한 경험담이 주를 이루고 있다.\nKotlin으로 개발하는 것이 낫다는 내용을 많이 보기도 하였고 개발에 욕심이 있다보니, 이번에는 기존에 JAVA로 개발되어 있던 코드에 Kotlin을 적용하여 새로 구성하거나 변경하는 클래스를 Kotlin으로 구성해보았다.\n다음은 이런 과정을 거치면서 느낀 장점과 단점에 대한 고찰이다.\n고찰  Kotlin의 장점을 느끼기 전에는 치명적인 단점(?)과 싸워야만 한다.","keywords":["java","legacy","kotlin","android","안드로이드","자바","코틀린","공존"],"articleBody":"Summary  안드로이드 개발 언어의 트렌드는 바뀌었다. 최근 Google I/O에서 나오는 샘플 코드들은 Kotlin으로 짜여져 있었다. 또한 안드로이드 개발 컨퍼런스의 주제는 Kotlin으로 개발한 경험담이 주를 이루고 있다.\nKotlin으로 개발하는 것이 낫다는 내용을 많이 보기도 하였고 개발에 욕심이 있다보니, 이번에는 기존에 JAVA로 개발되어 있던 코드에 Kotlin을 적용하여 새로 구성하거나 변경하는 클래스를 Kotlin으로 구성해보았다.\n다음은 이런 과정을 거치면서 느낀 장점과 단점에 대한 고찰이다.\n고찰  Kotlin의 장점을 느끼기 전에는 치명적인 단점(?)과 싸워야만 한다.\n무엇보다 가장 크게 힘들었던 점은 손에 익은 Java 대신에 인내하며 억지로 Kotlin으로 작성해야된다는 점이었다. 개발자가 새로운 기술을 받아들여야 할 때 나타나는 문제점이었다. 기존에 잘하는 것으로 개발하면 바로 끝낼 수 있지만 새로운 것을 받아들이면 공부하고 적용하는데까지 시간이 몇배로 들기 때문이다. 이런 경우에 기술을 받아들일지는 상황에 따라 결정하게 된다. 상급자의 명령에 따라 빠른 퍼포먼스를 보여줘야하는 경우에는 기존의 기술을 택한다. 반면에 중간중간에 공부를 해두어서 적용할 수 있는 단계가 된 경우이거나 개발의 주체가 기술에 대한 욕심이 있고 새로운 것에 대해 무리없이 받아들이는 경우에는 새로운 기술을 택한다. 솔직히 후자라고 주장하고 싶지만 지난 몇번의 시도를 하였지만 다시 Java로 개발했었다. 편하게 살고싶은 마음을 이겨내는 것이 제일 힘들었다.\n이번에는 마음을 먹고 .kotlin으로 파일을 생성하여 .java는 생성하지도 않았다. 여러 언어를 접하면서, 공부하면 기본은 비슷하기 때문에 적응만 하면 배울 수 있다는 것을 깨달았기 때문이다.\nKotlin을 적용하는 것은 만만하지 않았다. Java에선 타입을 먼저 지정하고 그에 대한 private / public / protected와 같은 scope를 정하며, 객체를 통해 모든 데이터를 전달하고 Interface를 통해 메서드들을 정했었다. 여태까지 자연스러운 행위였다.\nKotlin에서는 var / val를 통한 변수 선언만이 존재했다. 처음엔 익숙하지 않았다. 먼저 객체 타입을 지정하였던 이전과 비교하여 콜론 다음에 타입을 지정할 수 있었다. 게다가 콜론 다음에 타입을 지정하는 것은 필수가 아니었다. 어색했다. 하지만 이것을 이겨내는 방법은 간단하였다. Kotlin이 이런 방식을 택한 이유에 대해 Java로 개발할 때보다 불편하게 만들기 위한 것이 아니라는 것만 생각하면 되었다.\n코틀린에서는 변수 선언과 동시에 값을 할당 할 때에는 타입을 지정할 필요가 없었다. 왜냐하면 바로 뒤에 해당 객체의 형을 볼 수 있기 때문이다. 만약 변수선언과 동시에 값을 할당하지 않는다면, 타입을 콜론한 다음에 지정해주면 된다. 예제는 다음과 같다.\nprivate var str = \"SOME STRING\" // 할당된 값을 통해 간단히 타입을 추론할 수 있다. private var str : String // 값이 할당되지 않을 때 변수 선언과 관련해서 바뀐점은 특별히 편하다는 생각은 많이 들지 않았다. 하지만 람다식이나 inner anonymous를 구현함에 있어서 코드를 아주 간결하게 표현할 수 있다.\n자바에서는 다음과 같이 표현했다.\nnew Thread(new Runnable() { @override public void run() { // RUN SOME CODES  } }).start() // OR  new Thread(() - { // RUN SOME CODES }).start() 이를 코틀린으로 작성하면 다음과 같다.\nThread({ // RUN SOME CODES }).start() 코드가 java보다 간결하게 표현된 것을 확인할 수 있다. 람다식으로 표현된 것보다도 간결해진다. 하지만 이것만으로는 간결해졌다고 볼 수 없다.\n무엇보다 Kotlin에서 가장 매력적으로 느꼈던 부분은 functional programming의 특징이다. Java에서 Callback을 구현하기 위해서는 다음과 같은 프로세스로 진행해야한다.\n callback으로 사용할 메서드가 정의된 AInterface를 생성 Async하게 동작하는 AClass에서 AInterface를 parameter로 받는 aMethod 메서드 생성 aMethod를 호출하는 BClass에서 AInterface를 내부익명으로 새로 구현하던지 상속받아 this를 파라미터로 넘겨 실행 (물론 더 다양한 방법도 존재하지만 이게 흔한 방법이다.)  글로 표현하기도 참 쉽지 않다. 헷갈린다. 하지만 Kotlin으로 작성하면 아주 간단하다. 파라미터를 함수로 받고 그것을 실행만 하면된다. 물론 이 함수는 별도로 정의되어 있는 인터페이스나 클래스가 아니다. Javascript로 개발한 적이 있다면 이러한 Callback 기법이 편안하게 다가올 것이다. 상세하게 알고 싶다면 다음의 링크를 참고하면 된다.\nHigher-Order Functions and Lambdas\n 위처럼 Kotlin에 적응하기 위한 일련의 과정을 거치니 점점 개발 퍼포먼스가 증가하였다. Kotlin으로 작성하면 코드의 무게가 작아지는 것도 있고, 자잘한 Interface를 선언할 일도 줄어들었기 때문이다. 덕분에 순수하게 타자를 치는 시간도 줄었다.\n이렇게만 말하니 조금 안타깝지만 언어 선택이 개발에 있어서 엄청난 향상으로 나타나지 않는다는 것은 모두가 알 것이다. 웹서버 개발을 할 때에도 C, C#, PHP, JAVA, Go, Nodejs, Python 등등 다양한 방법이 있다. 그럼에도 불구하고, 우리가 최근에는 Go, Nodejs, C#, Python등으로 개발하는 이유가 있다. C가 익은 사람이라도 이제는 C로 웹서버를 개발하지 않는다. 왜냐하면 지속적인 개발을 위한 퍼포먼스에서 크게 차이가 나타나기 때문이다. 비록 처음에는 배움에 대한 문턱이 있다 할지라도, 결국에는 유지보수의 단계에서 비용절감의 결과로 나타날 것이다.\n개발 속도에 문제가 생기지 않도록 유지가능한 코드를 위해 Kotlin을 적극 도입하기를 추천한다.\n","wordCount":"634","inLanguage":"en","datePublished":"2018-05-28T11:30:03Z","dateModified":"2018-05-28T11:30:03Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://novemberde.github.io/post/2018/05/28/kotlin/"},"publisher":{"@type":"Organization","name":"Novemberde's Blog","logo":{"@type":"ImageObject","url":"https://novemberde.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8620431066400094" crossorigin=anonymous></script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://novemberde.github.io/ accesskey=h title="Novemberde's Blog (Alt + H)">Novemberde's Blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://novemberde.github.io/search title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://novemberde.github.io/post/ title=Post>
<span>Post</span>
</a>
</li>
<li>
<a href=https://novemberde.github.io/about title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://novemberde.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://novemberde.github.io/post/>Posts</a></div>
<h1 class=post-title>
Legacy android application, Kotlin 적용기
</h1>
<div class=post-meta>May 28, 2018&nbsp;·&nbsp;3 min
</div>
</header>
<div class=post-content><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2>
<hr>
<p>안드로이드 개발 언어의 트렌드는 바뀌었다. 최근 Google I/O에서 나오는
샘플 코드들은 Kotlin으로 짜여져 있었다. 또한 안드로이드 개발 컨퍼런스의
주제는 Kotlin으로 개발한 경험담이 주를 이루고 있다.</p>
<p>Kotlin으로 개발하는 것이 낫다는 내용을 많이 보기도 하였고 개발에 욕심이 있다보니,
이번에는 기존에 JAVA로 개발되어 있던 코드에 Kotlin을 적용하여 새로 구성하거나 변경하는
클래스를 Kotlin으로 구성해보았다.</p>
<p>다음은 이런 과정을 거치면서 느낀 장점과 단점에 대한 고찰이다.</p>
<h2 id=고찰>고찰<a hidden class=anchor aria-hidden=true href=#고찰>#</a></h2>
<hr>
<p>Kotlin의 장점을 느끼기 전에는 치명적인 단점(?)과 싸워야만 한다.</p>
<p>무엇보다 가장 크게 힘들었던 점은 손에 익은 Java 대신에 인내하며 억지로 Kotlin으로 작성해야된다는 점이었다.
개발자가 새로운 기술을 받아들여야 할 때 나타나는 문제점이었다. 기존에 잘하는 것으로 개발하면 바로 끝낼 수 있지만
새로운 것을 받아들이면 공부하고 적용하는데까지 시간이 몇배로 들기 때문이다.
이런 경우에 기술을 받아들일지는 상황에 따라 결정하게 된다.
상급자의 명령에 따라 빠른 퍼포먼스를 보여줘야하는 경우에는 기존의 기술을 택한다.
반면에 중간중간에 공부를 해두어서 적용할 수 있는 단계가 된 경우이거나
개발의 주체가 기술에 대한 욕심이 있고 새로운 것에 대해 무리없이 받아들이는 경우에는 새로운 기술을 택한다.
솔직히 후자라고 주장하고 싶지만 지난 몇번의 시도를 하였지만 다시 Java로 개발했었다.
편하게 살고싶은 마음을 이겨내는 것이 제일 힘들었다.</p>
<p>이번에는 마음을 먹고 .kotlin으로 파일을 생성하여 .java는 생성하지도 않았다.
여러 언어를 접하면서, 공부하면 기본은 비슷하기 때문에 적응만 하면 배울 수 있다는 것을
깨달았기 때문이다.</p>
<p>Kotlin을 적용하는 것은 만만하지 않았다.
Java에선 타입을 먼저 지정하고 그에 대한 private / public / protected와 같은 scope를 정하며, 객체를 통해
모든 데이터를 전달하고 Interface를 통해 메서드들을 정했었다.
여태까지 자연스러운 행위였다.</p>
<p>Kotlin에서는 var / val를 통한 변수 선언만이 존재했다.
처음엔 익숙하지 않았다. 먼저 객체 타입을 지정하였던 이전과 비교하여 콜론 다음에 타입을 지정할 수 있었다.
게다가 콜론 다음에 타입을 지정하는 것은 필수가 아니었다. 어색했다.
하지만 이것을 이겨내는 방법은 간단하였다.
Kotlin이 이런 방식을 택한 이유에 대해 Java로 개발할 때보다 불편하게 만들기 위한 것이 아니라는 것만 생각하면 되었다.</p>
<p>코틀린에서는 변수 선언과 동시에 값을 할당 할 때에는 타입을 지정할 필요가 없었다. 왜냐하면 바로 뒤에
해당 객체의 형을 볼 수 있기 때문이다. 만약 변수선언과 동시에 값을 할당하지 않는다면,
타입을 콜론한 다음에 지정해주면 된다.
예제는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> str = <span style=color:#e6db74>&#34;SOME STRING&#34;</span> <span style=color:#75715e>// 할당된 값을 통해 간단히 타입을 추론할 수 있다.
</span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> str : String        <span style=color:#75715e>// 값이 할당되지 않을 때
</span></code></pre></div><p>변수 선언과 관련해서 바뀐점은 특별히 편하다는 생각은 많이 들지 않았다.
하지만 람다식이나 inner anonymous를 구현함에 있어서 코드를 아주 간결하게 표현할 수 있다.</p>
<p>자바에서는 다음과 같이 표현했다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// RUN SOME CODES
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
<span style=color:#f92672>}).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>()</span>

<span style=color:#75715e>// OR
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>// RUN SOME CODES
</span><span style=color:#75715e></span><span style=color:#f92672>}).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>()</span>
</code></pre></div><p>이를 코틀린으로 작성하면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>Thread({
    <span style=color:#75715e>// RUN SOME CODES
</span><span style=color:#75715e></span>}).start()
</code></pre></div><p>코드가 java보다 간결하게 표현된 것을 확인할 수 있다. 람다식으로 표현된 것보다도 간결해진다.
하지만 이것만으로는 간결해졌다고 볼 수 없다.</p>
<p>무엇보다 Kotlin에서 가장 매력적으로 느꼈던 부분은 functional programming의 특징이다.
Java에서 Callback을 구현하기 위해서는 다음과 같은 프로세스로 진행해야한다.</p>
<ol>
<li>callback으로 사용할 메서드가 정의된 AInterface를 생성</li>
<li>Async하게 동작하는 AClass에서 AInterface를 parameter로 받는 aMethod 메서드 생성</li>
<li>aMethod를 호출하는 BClass에서 AInterface를 내부익명으로 새로 구현하던지 상속받아 this를 파라미터로 넘겨 실행
(물론 더 다양한 방법도 존재하지만 이게 흔한 방법이다.)</li>
</ol>
<p>글로 표현하기도 참 쉽지 않다. 헷갈린다. 하지만 Kotlin으로 작성하면 아주 간단하다.
파라미터를 함수로 받고 그것을 실행만 하면된다. 물론 이 함수는 별도로 정의되어 있는 인터페이스나 클래스가 아니다.
Javascript로 개발한 적이 있다면 이러한 Callback 기법이 편안하게 다가올 것이다.
상세하게 알고 싶다면 다음의 링크를 참고하면 된다.</p>
<p><a href=https://kotlinlang.org/docs/reference/lambdas.html>Higher-Order Functions and Lambdas</a></p>
<hr>
<p>위처럼 Kotlin에 적응하기 위한 일련의 과정을 거치니 점점 개발 퍼포먼스가 증가하였다.
Kotlin으로 작성하면 코드의 무게가 작아지는 것도 있고, 자잘한 Interface를
선언할 일도 줄어들었기 때문이다.
덕분에 순수하게 타자를 치는 시간도 줄었다.</p>
<p>이렇게만 말하니 조금 안타깝지만 언어 선택이 개발에 있어서 엄청난 향상으로 나타나지 않는다는 것은 모두가 알 것이다.
웹서버 개발을 할 때에도 C, C#, PHP, JAVA, Go, Nodejs, Python 등등 다양한 방법이 있다.
그럼에도 불구하고, 우리가 최근에는 Go, Nodejs, C#, Python등으로 개발하는 이유가 있다.
C가 익은 사람이라도 이제는 C로 웹서버를 개발하지 않는다. 왜냐하면 지속적인 개발을 위한 퍼포먼스에서
크게 차이가 나타나기 때문이다. 비록 처음에는 배움에 대한 문턱이 있다 할지라도, 결국에는 유지보수의 단계에서
비용절감의 결과로 나타날 것이다.</p>
<p>개발 속도에 문제가 생기지 않도록 유지가능한 코드를 위해 Kotlin을 적극 도입하기를 추천한다.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://novemberde.github.io/tags/java/>java</a></li>
<li><a href=https://novemberde.github.io/tags/legacy/>legacy</a></li>
<li><a href=https://novemberde.github.io/tags/kotlin/>kotlin</a></li>
<li><a href=https://novemberde.github.io/tags/android/>android</a></li>
<li><a href=https://novemberde.github.io/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/>안드로이드</a></li>
<li><a href=https://novemberde.github.io/tags/%EC%9E%90%EB%B0%94/>자바</a></li>
<li><a href=https://novemberde.github.io/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/>코틀린</a></li>
<li><a href=https://novemberde.github.io/tags/%EA%B3%B5%EC%A1%B4/>공존</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://novemberde.github.io/post/2018/06/20/AWS-config-switching/>
<span class=title>« Prev Page</span>
<br>
<span>AWS Configure 여러 계정으로 스위칭하며 사용하기</span>
</a>
<a class=next href=https://novemberde.github.io/post/2018/05/24/String/>
<span class=title>Next Page »</span>
<br>
<span>The difference among String, StringBuilder, and StringBuffer in JAVA</span>
</a>
</nav>
</footer>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//novemberde-github-io.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://novemberde.github.io/>Novemberde's Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>