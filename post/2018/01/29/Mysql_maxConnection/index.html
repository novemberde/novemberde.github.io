<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>AWS Lambda와 MySQL의 max connection 문제 | Novemberde's Blog</title>
<meta name=keywords content="lambda,concurrency,mysql,database,max,connection,max_connections,병렬">
<meta name=description content="Summary  MySQL에서 Max Connection에 대해서 알아보려고 한다. AWS Lambda container가 지속적으로 생성될 때 Database가 감당할 수 있는 Max connection이 얼마인지 알아야 대응할 수 있기 때문이다. 만약 Lambda container가 MySQL이 감당할 수 없을 정도로 계속 생성된다면 Database에 connection이 일어나지 않게 되고, too many connections error가 발생하여 웹서버 역할을 해야하는 Lambda가 동작하지 않을 수 있다. 물론 MySQL에 접속하는 다른 Worker들도 동작하지 않는다.
RDS를 사용하면 스케일 업이 될 때마다 Max connection 설정을 따로 하지 않더라도 알아서 늘어난다.">
<meta name=author content>
<link rel=canonical href=https://novemberde.github.io/post/2018/01/29/Mysql_maxConnection/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.9f1d947375927e9847272b1f4e9be81336f539e513bf04d52cade31f81cad1af.css integrity="sha256-nx2Uc3WSfphHJysfTpvoEzb1OeUTvwTVLK3jH4HK0a8=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://novemberde.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://novemberde.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://novemberde.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://novemberde.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://novemberde.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-97433460-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="AWS Lambda와 MySQL의 max connection 문제">
<meta property="og:description" content="Summary  MySQL에서 Max Connection에 대해서 알아보려고 한다. AWS Lambda container가 지속적으로 생성될 때 Database가 감당할 수 있는 Max connection이 얼마인지 알아야 대응할 수 있기 때문이다. 만약 Lambda container가 MySQL이 감당할 수 없을 정도로 계속 생성된다면 Database에 connection이 일어나지 않게 되고, too many connections error가 발생하여 웹서버 역할을 해야하는 Lambda가 동작하지 않을 수 있다. 물론 MySQL에 접속하는 다른 Worker들도 동작하지 않는다.
RDS를 사용하면 스케일 업이 될 때마다 Max connection 설정을 따로 하지 않더라도 알아서 늘어난다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://novemberde.github.io/post/2018/01/29/Mysql_maxConnection/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2018-01-29T11:30:03+00:00">
<meta property="article:modified_time" content="2018-01-29T11:30:03+00:00"><meta property="og:site_name" content="Novemberde dev logs">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="AWS Lambda와 MySQL의 max connection 문제">
<meta name=twitter:description content="Summary  MySQL에서 Max Connection에 대해서 알아보려고 한다. AWS Lambda container가 지속적으로 생성될 때 Database가 감당할 수 있는 Max connection이 얼마인지 알아야 대응할 수 있기 때문이다. 만약 Lambda container가 MySQL이 감당할 수 없을 정도로 계속 생성된다면 Database에 connection이 일어나지 않게 되고, too many connections error가 발생하여 웹서버 역할을 해야하는 Lambda가 동작하지 않을 수 있다. 물론 MySQL에 접속하는 다른 Worker들도 동작하지 않는다.
RDS를 사용하면 스케일 업이 될 때마다 Max connection 설정을 따로 하지 않더라도 알아서 늘어난다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://novemberde.github.io/post/"},{"@type":"ListItem","position":2,"name":"AWS Lambda와 MySQL의 max connection 문제","item":"https://novemberde.github.io/post/2018/01/29/Mysql_maxConnection/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AWS Lambda와 MySQL의 max connection 문제","name":"AWS Lambda와 MySQL의 max connection 문제","description":"Summary  MySQL에서 Max Connection에 대해서 알아보려고 한다. AWS Lambda container가 지속적으로 생성될 때 Database가 감당할 수 있는 Max connection이 얼마인지 알아야 대응할 수 있기 때문이다. 만약 Lambda container가 MySQL이 감당할 수 없을 정도로 계속 생성된다면 Database에 connection이 일어나지 않게 되고, too many connections error가 발생하여 웹서버 역할을 해야하는 Lambda가 동작하지 않을 수 있다. 물론 MySQL에 접속하는 다른 Worker들도 동작하지 않는다.\nRDS를 사용하면 스케일 업이 될 때마다 Max connection 설정을 따로 하지 않더라도 알아서 늘어난다.","keywords":["lambda","concurrency","mysql","database","max","connection","max_connections","병렬"],"articleBody":"Summary  MySQL에서 Max Connection에 대해서 알아보려고 한다. AWS Lambda container가 지속적으로 생성될 때 Database가 감당할 수 있는 Max connection이 얼마인지 알아야 대응할 수 있기 때문이다. 만약 Lambda container가 MySQL이 감당할 수 없을 정도로 계속 생성된다면 Database에 connection이 일어나지 않게 되고, too many connections error가 발생하여 웹서버 역할을 해야하는 Lambda가 동작하지 않을 수 있다. 물론 MySQL에 접속하는 다른 Worker들도 동작하지 않는다.\nRDS를 사용하면 스케일 업이 될 때마다 Max connection 설정을 따로 하지 않더라도 알아서 늘어난다. 별다른 고민할 것 없이 Max connection이 생길 때마다 RDS를 scale up 해주어도 되겠지만 개발자이기 때문에 더 Graceful하게 문제를 해결해야한다.\nMySQL에서 max connection 확인하기  MySQL에서 max connection을 확인하는 쿼리는 다음과 같다.\nshow variables like 'max_connections'; 그리고 RDS instance type에 따른 max_connections는 다음과 같다.\n 2.micro: 66 t2.small: 150 m3.medium: 296 t2.medium: 312 M3.large: 609 t2.large: 648 M4.large: 648 M3.xlarge: 1237 R3.large: 1258 M4.xlarge: 1320 M2.xlarge: 1412 M3.2xlarge: 2492 R3.xlarge: 2540  Amazon Aurora의 instance type에 따른 max_connections는 다음과 같다.\n db.t2.small: 45 db.t2.medium: 90 db.r3.large: 1000 db.r3.xlarge: 2000 db.r3.2xlarge: 3000 db.r3.4xlarge: 4000 db.r3.8xlarge: 5000 db.r4.large: 1000 db.r4.xlarge: 2000 db.r4.2xlarge: 3000 db.r4.4xlarge: 4000 db.r4.8xlarge: 5000 db.r4.16xlarge: 6000  사용하는 Persistance framework의 Connection pool size알기  WebApp 또는 Worker에서 동작하는 connection pool 옵션을 확인하고 RDS가 사용되는 max_connection의 수를 나누면 대략적으로 Concurrency하게 동작하는 개수를 알아낼 수 있다.\n그 다음 Lambda의 옵션 중 concurrency 옵션을 수정하면 된다.\n고찰 현재 업무에서 사용하는 모든 웹앱이 AWS Lambda에서 동작하고 있다. 점점 사용자가 늘어감에 따라 가끔 설계해놓은 스펙 이상으로 부하가 몰릴 경우가 있다. Lambda에서 Timeout이 빈번하게 발생할 경우 timeout되기 전 상태의 lambda가 계속 생성되어 순간적으로 RDS의 connection에 문제가 생겼었다. 물론 Lambda timeout을 큰 고찰없이 10초 이상으로 설정해 놓을 수도 있다. 예를 들어, 10초 사이에 많은 요청이 생긴다고 가정해보자. rds는 (컨테이너의 수*connection pool수)만큼 connection을 맺는데, timeout으로 끝나는 컨테이너가 많아질수록 RDS의 max_connections옵션을 초과하여 too many connections error를 내뿜게 된다. 결과적으로 클라이언트들은 원하는 상태를 처리하기 위해 지속적인 요청을 보낼 것이고 RDS는 CPU 100%로 클라이언트가 진정될 때까지 계속 힘들어할 것이다.\n이런 문제점 때문에 Timeout도 길게 설정하지 말고 4~8초 내외로 잡는 것이 낫다. 물론 배치잡같은 경우를 제외하고 말이다. 이렇게 되면 어느정도 too many connections error를 잡는데 도움을 준다.\n그렇지만 무엇보다 비지니스 로직에서 최적화를 잘 시켜서 timeout상태를 만들지 않는게 중요할 것이다.\n2019-12-22 업데이트 최근에 RDS Proxy라는 것이 릴리즈되었다. 이는 RDS의 Connection Pool을 제공하고 API를 통해 RDS에 접근한다. 기존의 Serverless Architecture에서 힘들게 한 Max Connection 문제에 대해서 해결하기 쉽게 해준다. 현재는 MySQL만 지원하면 다른 유형의 데이터베이스는 추후에 지원될 예정이다.\n해당 내용은 여기(https://aws.amazon.com/ko/rds/proxy/)서 확인할 수 있다.\n","wordCount":"388","inLanguage":"en","datePublished":"2018-01-29T11:30:03Z","dateModified":"2018-01-29T11:30:03Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://novemberde.github.io/post/2018/01/29/Mysql_maxConnection/"},"publisher":{"@type":"Organization","name":"Novemberde's Blog","logo":{"@type":"ImageObject","url":"https://novemberde.github.io/favicon.ico"}}}</script><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script>
<script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8620431066400094",enable_page_level_ads:!0})</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://novemberde.github.io/ accesskey=h title="Novemberde's Blog (Alt + H)">Novemberde's Blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://novemberde.github.io/post/ title=Post>
<span>Post</span>
</a>
</li>
<li>
<a href=https://novemberde.github.io/about title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://novemberde.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://novemberde.github.io/post/>Posts</a></div>
<h1 class=post-title>
AWS Lambda와 MySQL의 max connection 문제
</h1>
<div class=post-meta>January 29, 2018&nbsp;·&nbsp;2 min
</div>
</header>
<div class=post-content><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2>
<hr>
<p>MySQL에서 Max Connection에 대해서 알아보려고 한다. AWS Lambda container가 지속적으로 생성될 때
Database가 감당할 수 있는 Max connection이 얼마인지 알아야 대응할 수 있기 때문이다.
만약 Lambda container가 MySQL이 감당할 수 없을 정도로 계속 생성된다면 Database에 connection이
일어나지 않게 되고, too many connections error가 발생하여 웹서버 역할을 해야하는 Lambda가 동작하지 않을 수 있다.
물론 MySQL에 접속하는 다른 Worker들도 동작하지 않는다.</p>
<p>RDS를 사용하면 스케일 업이 될 때마다 Max connection 설정을 따로 하지 않더라도 알아서 늘어난다.
별다른 고민할 것 없이 Max connection이 생길 때마다 RDS를 scale up 해주어도 되겠지만 개발자이기 때문에
더 Graceful하게 문제를 해결해야한다.</p>
<h2 id=mysql에서-max-connection-확인하기>MySQL에서 max connection 확인하기<a hidden class=anchor aria-hidden=true href=#mysql에서-max-connection-확인하기>#</a></h2>
<hr>
<p>MySQL에서 max connection을 확인하는 쿼리는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>show</span> variables <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;max_connections&#39;</span>;
</code></pre></div><p>그리고 RDS instance type에 따른 max_connections는 다음과 같다.</p>
<ul>
<li>2.micro: 66</li>
<li>t2.small: 150</li>
<li>m3.medium: 296</li>
<li>t2.medium: 312</li>
<li>M3.large: 609</li>
<li>t2.large: 648</li>
<li>M4.large: 648</li>
<li>M3.xlarge: 1237</li>
<li>R3.large: 1258</li>
<li>M4.xlarge: 1320</li>
<li>M2.xlarge: 1412</li>
<li>M3.2xlarge: 2492</li>
<li>R3.xlarge: 2540</li>
</ul>
<p>Amazon Aurora의 instance type에 따른 max_connections는 다음과 같다.</p>
<ul>
<li>db.t2.small: 45</li>
<li>db.t2.medium: 90</li>
<li>db.r3.large: 1000</li>
<li>db.r3.xlarge: 2000</li>
<li>db.r3.2xlarge: 3000</li>
<li>db.r3.4xlarge: 4000</li>
<li>db.r3.8xlarge: 5000</li>
<li>db.r4.large: 1000</li>
<li>db.r4.xlarge: 2000</li>
<li>db.r4.2xlarge: 3000</li>
<li>db.r4.4xlarge: 4000</li>
<li>db.r4.8xlarge: 5000</li>
<li>db.r4.16xlarge: 6000</li>
</ul>
<h2 id=사용하는-persistance-framework의-connection-pool-size알기>사용하는 Persistance framework의 Connection pool size알기<a hidden class=anchor aria-hidden=true href=#사용하는-persistance-framework의-connection-pool-size알기>#</a></h2>
<hr>
<p>WebApp 또는 Worker에서 동작하는 connection pool 옵션을 확인하고
RDS가 사용되는 max_connection의 수를 나누면 대략적으로 Concurrency하게 동작하는 개수를 알아낼 수 있다.</p>
<p>그 다음 Lambda의 옵션 중 concurrency 옵션을 수정하면 된다.</p>
<h2 id=고찰>고찰<a hidden class=anchor aria-hidden=true href=#고찰>#</a></h2>
<p>현재 업무에서 사용하는 모든 웹앱이 AWS Lambda에서 동작하고 있다. 점점 사용자가 늘어감에 따라
가끔 설계해놓은 스펙 이상으로 부하가 몰릴 경우가 있다. Lambda에서 Timeout이 빈번하게 발생할 경우
timeout되기 전 상태의 lambda가 계속 생성되어 순간적으로 RDS의 connection에 문제가 생겼었다.
물론 Lambda timeout을 큰 고찰없이 10초 이상으로 설정해 놓을 수도 있다.
예를 들어, 10초 사이에 많은 요청이 생긴다고 가정해보자.
rds는 (컨테이너의 수*connection pool수)만큼 connection을 맺는데,
timeout으로 끝나는 컨테이너가 많아질수록 RDS의 max_connections옵션을 초과하여
too many connections error를 내뿜게 된다.
결과적으로 클라이언트들은 원하는 상태를 처리하기 위해 지속적인 요청을 보낼 것이고 RDS는 CPU 100%로 클라이언트가 진정될 때까지
계속 힘들어할 것이다.</p>
<p>이런 문제점 때문에 Timeout도 길게 설정하지 말고 4~8초 내외로 잡는 것이 낫다. 물론 배치잡같은 경우를 제외하고 말이다.
이렇게 되면 어느정도 too many connections error를 잡는데 도움을 준다.</p>
<p>그렇지만 무엇보다 비지니스 로직에서 최적화를 잘 시켜서 timeout상태를 만들지 않는게 중요할 것이다.</p>
<h2 id=2019-12-22-업데이트>2019-12-22 업데이트<a hidden class=anchor aria-hidden=true href=#2019-12-22-업데이트>#</a></h2>
<p>최근에 RDS Proxy라는 것이 릴리즈되었다. 이는 RDS의 Connection Pool을 제공하고
API를 통해 RDS에 접근한다.
기존의 Serverless Architecture에서 힘들게 한 Max Connection 문제에 대해서 해결하기 쉽게 해준다.
현재는 MySQL만 지원하면 다른 유형의 데이터베이스는 추후에 지원될 예정이다.</p>
<p>해당 내용은 <a href=https://aws.amazon.com/ko/rds/proxy/>여기(https://aws.amazon.com/ko/rds/proxy/)</a>서 확인할 수 있다.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://novemberde.github.io/tags/lambda/>lambda</a></li>
<li><a href=https://novemberde.github.io/tags/concurrency/>concurrency</a></li>
<li><a href=https://novemberde.github.io/tags/mysql/>mysql</a></li>
<li><a href=https://novemberde.github.io/tags/database/>database</a></li>
<li><a href=https://novemberde.github.io/tags/max/>max</a></li>
<li><a href=https://novemberde.github.io/tags/connection/>connection</a></li>
<li><a href=https://novemberde.github.io/tags/max_connections/>max_connections</a></li>
<li><a href=https://novemberde.github.io/tags/%EB%B3%91%EB%A0%AC/>병렬</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://novemberde.github.io/post/2018/02/02/Lambda_coldStart/>
<span class=title>« Prev Page</span>
<br>
<span>AWS Lambda에서의 Cold Start 문제 해결하기(Golang + serverless framework)</span>
</a>
<a class=next href=https://novemberde.github.io/post/2018/01/20/ECS_Fargate/>
<span class=title>Next Page »</span>
<br>
<span>ECS & Fargate Demo</span>
</a>
</nav>
</footer>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//novemberde-github-io.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://novemberde.github.io/>Novemberde's Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>