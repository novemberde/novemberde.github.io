<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>AWS Lambda에서의 Cold Start 문제 해결하기(Golang + serverless framework) | Novemberde's Blog</title>
<meta name=keywords content="apigateway,lambda,serverless,framework,go,golang,go언어,coldstart,cold,start,문제">
<meta name=description content="Summary  AWS Lambda와 API Gateway를 연동하여 웹서버를 Serverless architecture로 운영하고 있다. 관리할 서버가 없고 비지니스 로직에만 집중할 수 있어서 좋기도 하지만 항상 Lambda container가 대기중인 상태가 아니다 보니 Cold start관련하여 요청사항이 발생했다.
일정시간이 경과된 후에 해당 페이지를 접속할 경우에 로딩이 3~4초이상 걸리기 때문에 사용이 불편하였다. 이를 해결하기 위해 5분마다 각 api를 health check하는 scheduler를 두기로 결정하였다. 그렇게되면 지속적인 lambda 호출로 인해 항상 하나이상의 lambda container가 대기하는 형태가 되어 lambda의 cold start의 가장 큰 시간을 소비하는 DB connection의 시간을 느낄 수 없다.">
<meta name=author content>
<link rel=canonical href=https://novemberde.github.io/post/2018/02/02/Lambda_coldStart/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.9f1d947375927e9847272b1f4e9be81336f539e513bf04d52cade31f81cad1af.css integrity="sha256-nx2Uc3WSfphHJysfTpvoEzb1OeUTvwTVLK3jH4HK0a8=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://novemberde.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://novemberde.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://novemberde.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://novemberde.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://novemberde.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-97433460-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="AWS Lambda에서의 Cold Start 문제 해결하기(Golang + serverless framework)">
<meta property="og:description" content="Summary  AWS Lambda와 API Gateway를 연동하여 웹서버를 Serverless architecture로 운영하고 있다. 관리할 서버가 없고 비지니스 로직에만 집중할 수 있어서 좋기도 하지만 항상 Lambda container가 대기중인 상태가 아니다 보니 Cold start관련하여 요청사항이 발생했다.
일정시간이 경과된 후에 해당 페이지를 접속할 경우에 로딩이 3~4초이상 걸리기 때문에 사용이 불편하였다. 이를 해결하기 위해 5분마다 각 api를 health check하는 scheduler를 두기로 결정하였다. 그렇게되면 지속적인 lambda 호출로 인해 항상 하나이상의 lambda container가 대기하는 형태가 되어 lambda의 cold start의 가장 큰 시간을 소비하는 DB connection의 시간을 느낄 수 없다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://novemberde.github.io/post/2018/02/02/Lambda_coldStart/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2018-02-02T11:30:03+00:00">
<meta property="article:modified_time" content="2018-02-02T11:30:03+00:00"><meta property="og:site_name" content="Novemberde dev logs">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="AWS Lambda에서의 Cold Start 문제 해결하기(Golang + serverless framework)">
<meta name=twitter:description content="Summary  AWS Lambda와 API Gateway를 연동하여 웹서버를 Serverless architecture로 운영하고 있다. 관리할 서버가 없고 비지니스 로직에만 집중할 수 있어서 좋기도 하지만 항상 Lambda container가 대기중인 상태가 아니다 보니 Cold start관련하여 요청사항이 발생했다.
일정시간이 경과된 후에 해당 페이지를 접속할 경우에 로딩이 3~4초이상 걸리기 때문에 사용이 불편하였다. 이를 해결하기 위해 5분마다 각 api를 health check하는 scheduler를 두기로 결정하였다. 그렇게되면 지속적인 lambda 호출로 인해 항상 하나이상의 lambda container가 대기하는 형태가 되어 lambda의 cold start의 가장 큰 시간을 소비하는 DB connection의 시간을 느낄 수 없다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://novemberde.github.io/post/"},{"@type":"ListItem","position":2,"name":"AWS Lambda에서의 Cold Start 문제 해결하기(Golang + serverless framework)","item":"https://novemberde.github.io/post/2018/02/02/Lambda_coldStart/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AWS Lambda에서의 Cold Start 문제 해결하기(Golang + serverless framework)","name":"AWS Lambda에서의 Cold Start 문제 해결하기(Golang \u002b serverless framework)","description":"Summary  AWS Lambda와 API Gateway를 연동하여 웹서버를 Serverless architecture로 운영하고 있다. 관리할 서버가 없고 비지니스 로직에만 집중할 수 있어서 좋기도 하지만 항상 Lambda container가 대기중인 상태가 아니다 보니 Cold start관련하여 요청사항이 발생했다.\n일정시간이 경과된 후에 해당 페이지를 접속할 경우에 로딩이 3~4초이상 걸리기 때문에 사용이 불편하였다. 이를 해결하기 위해 5분마다 각 api를 health check하는 scheduler를 두기로 결정하였다. 그렇게되면 지속적인 lambda 호출로 인해 항상 하나이상의 lambda container가 대기하는 형태가 되어 lambda의 cold start의 가장 큰 시간을 소비하는 DB connection의 시간을 느낄 수 없다.","keywords":["apigateway","lambda","serverless","framework","go","golang","go언어","coldstart","cold","start","문제"],"articleBody":"Summary  AWS Lambda와 API Gateway를 연동하여 웹서버를 Serverless architecture로 운영하고 있다. 관리할 서버가 없고 비지니스 로직에만 집중할 수 있어서 좋기도 하지만 항상 Lambda container가 대기중인 상태가 아니다 보니 Cold start관련하여 요청사항이 발생했다.\n일정시간이 경과된 후에 해당 페이지를 접속할 경우에 로딩이 3~4초이상 걸리기 때문에 사용이 불편하였다. 이를 해결하기 위해 5분마다 각 api를 health check하는 scheduler를 두기로 결정하였다. 그렇게되면 지속적인 lambda 호출로 인해 항상 하나이상의 lambda container가 대기하는 형태가 되어 lambda의 cold start의 가장 큰 시간을 소비하는 DB connection의 시간을 느낄 수 없다.\n먼저 현재 사용하는 웹서버가 5개라고 하고, heathCheck는 비지니스 로직을 통과하지 않고 빠른 응답을 하기 때문에 처음에는 300ms에 응답한다고 가정하려하였다. 그런데 5분에 한 번씩 모든 api를 호출하고, 돌아오는 응답의 시간이 대략적으로 2초정도 걸렸다.\n무엇인가 이상하다고 생각하였다.\n단순한 request인데 몇번하였다고 2초가 걸리는 건 코드상의 오류라고 생각되었다. 이때 Go lang을 활용하였는데, 익숙치 않다보니 실수가 있었다.\n기존의 node로 개발했을 때는 Promise.all 패턴으로 비동기 작업을 한번에 보냈었지만, go로 생각없이 짜다보니 request하고 응답하고 request하고 응답하고 이런식으로 여러번하다보니 전체적인 시간이 늘어났다. 얼마되진 않지만 이 때문에 비용이 4배 이상으로 올라가서 Gorutine를 사용하여 처리하였다.\n동시에 요청을 보내고 전부 response를 받으면 lambda가 종료하는 방식이다. 기존에는 2초가 걸렸지만 현재는 1.5초로 실행시간을 감소시켰다. 빠른 때는 1초도 걸리지 않는다.\n 비용 계산하기  위 테스트를 기반으로 https://s3.amazonaws.com/lambda-tools/pricing-calculator.html에서 참고하여 비용을 측정하였다.\n Number of Executions: 5 * 12(시간당 호출수) * 24 * 30 = 43200 Memory: 단순 로직이기 때문에 128MB로 선정 Estimated Execution Time (ms): 1500ms Include Free Tier: no TOTAL COSTS  Request Costs: $0.01 Execution Costs: $0.14 $0.14/month    계산에 따르면 한달에 200원 정도선에서 모든 api를 Healthy상태로 둘 수 있다.\n현재 가격은 최대로 계산한 것이고 Lambda의 메트릭을 살펴보면 비용은 좀 더 낮게 책정될 것을 예상할 수 있다. 보통은 1초 내외로 끝나기 때문이다.\n 고찰  본격적으로 go언어를 사용하기로 마음을 먹고 이번에 실제로 적용해본 것은 처음이다. 기존에 스크립트 언어에 익숙했기 때문에 적응은 쉽게 되지 않았다. 기본적으로 스크립트 언어는 async한 로직을 쉽게 넣었지만 compile언어를 오랜만에 써보니 비동기 작업을 다르게 구현하는 점이 새로웠다. 물론 JAVA에서 Thread를 통해 비동기 작업을 처리하기도 했지만 gorutine을 통해 로직을 구현해보니 상당히 golang이 매력적인 녀석이라는 것을 깨달았다.\nJava처럼 각 request 마다 thread를 생성하지 않고 gorutine의 channel을 통한 방식이 아직은 낯설기도 하지만 점차 적응해나갈 것으로 보인다.\n그리고 node를 사용한 serverless deploy는 바로 소스코드를 업로드하는 방식이었지만 go는 해당 application을 Makefile 을 통해 빌드하고 bin 디렉터리만 serverless deploy를 하는 형식이었다. 이것은 go가 컴파일 언어이기 때문에 컴파일된 binany형태의 파일만으로 동작하기 때문이다.\n왜 기존에 잘 쓰던 node를 두고 golang으로 작성하였는지 물어본다면 performance에 대한 욕구가 나날이 증가하기 때문이다. 현재 서비스가 성장해감에 따라서 web-application의 성능의 차이가 느껴지기 시작했다. node는 결국 script언어이기 때문에 compile 언어와 차이가 날 수 밖에 없기 때문이다. 그렇다고 java를 사용하기엔 lambda에 jvm이 얹혀가는 구조이기 때문에 무겁게 동작해서 사용할 수가 없었다.\ngo언어를 점차 사용해서 모든 프로덕션에 적용하는게 목표이지만 언제 이룰 수 있을진 잘 모르겠다.\n References   https://s3.amazonaws.com/lambda-tools/pricing-calculator.html  ","wordCount":"434","inLanguage":"en","datePublished":"2018-02-02T11:30:03Z","dateModified":"2018-02-02T11:30:03Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://novemberde.github.io/post/2018/02/02/Lambda_coldStart/"},"publisher":{"@type":"Organization","name":"Novemberde's Blog","logo":{"@type":"ImageObject","url":"https://novemberde.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8620431066400094" crossorigin=anonymous></script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://novemberde.github.io/ accesskey=h title="Novemberde's Blog (Alt + H)">Novemberde's Blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://novemberde.github.io/search title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://novemberde.github.io/post/ title=Post>
<span>Post</span>
</a>
</li>
<li>
<a href=https://novemberde.github.io/about title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://novemberde.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://novemberde.github.io/post/>Posts</a></div>
<h1 class=post-title>
AWS Lambda에서의 Cold Start 문제 해결하기(Golang + serverless framework)
</h1>
<div class=post-meta>February 2, 2018&nbsp;·&nbsp;3 min
</div>
</header>
<div class=post-content><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2>
<hr>
<p>AWS Lambda와 API Gateway를 연동하여 웹서버를 Serverless architecture로 운영하고 있다.
관리할 서버가 없고 비지니스 로직에만 집중할 수 있어서 좋기도 하지만 항상 Lambda container가
대기중인 상태가 아니다 보니 Cold start관련하여 요청사항이 발생했다.</p>
<p>일정시간이 경과된 후에 해당 페이지를 접속할 경우에 로딩이 3~4초이상 걸리기 때문에 사용이 불편하였다.
이를 해결하기 위해 5분마다 각 api를 health check하는 scheduler를 두기로 결정하였다.
그렇게되면 지속적인 lambda 호출로 인해 항상 하나이상의 lambda container가 대기하는 형태가 되어
lambda의 cold start의 가장 큰 시간을 소비하는 DB connection의 시간을 느낄 수 없다.</p>
<p>먼저 현재 사용하는 웹서버가 5개라고 하고, heathCheck는 비지니스 로직을 통과하지 않고
빠른 응답을 하기 때문에 처음에는 300ms에 응답한다고 가정하려하였다.
그런데 5분에 한 번씩 모든 api를 호출하고, 돌아오는 응답의 시간이 대략적으로 2초정도 걸렸다.</p>
<p>무엇인가 이상하다고 생각하였다.</p>
<p>단순한 request인데 몇번하였다고 2초가 걸리는 건 코드상의 오류라고 생각되었다.
이때 Go lang을 활용하였는데, 익숙치 않다보니 실수가 있었다.</p>
<p>기존의 node로 개발했을 때는 Promise.all 패턴으로 비동기 작업을 한번에 보냈었지만,
go로 생각없이 짜다보니 request하고 응답하고 request하고 응답하고
이런식으로 여러번하다보니 전체적인 시간이 늘어났다. 얼마되진 않지만 이 때문에
비용이 4배 이상으로 올라가서 Gorutine를 사용하여 처리하였다.</p>
<p>동시에 요청을 보내고 전부 response를 받으면 lambda가 종료하는 방식이다.
기존에는 2초가 걸렸지만 현재는 1.5초로 실행시간을 감소시켰다. 빠른 때는 1초도 걸리지 않는다.</p>
<hr>
<h2 id=비용-계산하기>비용 계산하기<a hidden class=anchor aria-hidden=true href=#비용-계산하기>#</a></h2>
<hr>
<p>위 테스트를 기반으로
<a href=https://s3.amazonaws.com/lambda-tools/pricing-calculator.html>https://s3.amazonaws.com/lambda-tools/pricing-calculator.html</a>에서
참고하여 비용을 측정하였다.</p>
<ul>
<li>Number of Executions: 5 * 12(시간당 호출수) * 24 * 30 = 43200</li>
<li>Memory: 단순 로직이기 때문에 128MB로 선정</li>
<li>Estimated Execution Time (ms): 1500ms</li>
<li>Include Free Tier: no</li>
<li>TOTAL COSTS
<ul>
<li>Request Costs: $0.01</li>
<li>Execution Costs: $0.14</li>
<li>$0.14/month</li>
</ul>
</li>
</ul>
<p>계산에 따르면 한달에 200원 정도선에서 모든 api를 Healthy상태로 둘 수 있다.</p>
<p>현재 가격은 최대로 계산한 것이고 Lambda의 메트릭을 살펴보면 비용은 좀 더 낮게 책정될 것을 예상할 수 있다.
보통은 1초 내외로 끝나기 때문이다.</p>
<p><img loading=lazy src=/images/aws/lambda/lambda_metric.png alt="lambda metric">
</p>
<hr>
<h2 id=고찰>고찰<a hidden class=anchor aria-hidden=true href=#고찰>#</a></h2>
<hr>
<p>본격적으로 go언어를 사용하기로 마음을 먹고 이번에 실제로 적용해본 것은 처음이다.
기존에 스크립트 언어에 익숙했기 때문에 적응은 쉽게 되지 않았다.
기본적으로 스크립트 언어는 async한 로직을 쉽게 넣었지만
compile언어를 오랜만에 써보니 비동기 작업을 다르게 구현하는 점이 새로웠다.
물론 JAVA에서 Thread를 통해 비동기 작업을 처리하기도 했지만 gorutine을 통해
로직을 구현해보니 상당히 golang이 매력적인 녀석이라는 것을 깨달았다.</p>
<p>Java처럼 각 request 마다 thread를 생성하지 않고 gorutine의 channel을 통한
방식이 아직은 낯설기도 하지만 점차 적응해나갈 것으로 보인다.</p>
<p>그리고 node를 사용한 serverless deploy는 바로 소스코드를 업로드하는 방식이었지만
go는 해당 application을 Makefile 을 통해 빌드하고 bin 디렉터리만 serverless deploy를 하는 형식이었다.
이것은 go가 컴파일 언어이기 때문에 컴파일된 binany형태의 파일만으로 동작하기 때문이다.</p>
<p>왜 기존에 잘 쓰던 node를 두고 golang으로 작성하였는지 물어본다면 performance에 대한
욕구가 나날이 증가하기 때문이다. 현재 서비스가 성장해감에 따라서 web-application의 성능의
차이가 느껴지기 시작했다. node는 결국 script언어이기 때문에 compile 언어와 차이가 날 수 밖에 없기 때문이다.
그렇다고 java를 사용하기엔 lambda에 jvm이 얹혀가는 구조이기 때문에 무겁게 동작해서 사용할 수가 없었다.</p>
<p>go언어를 점차 사용해서 모든 프로덕션에 적용하는게 목표이지만 언제 이룰 수 있을진 잘 모르겠다.</p>
<hr>
<h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2>
<hr>
<ul>
<li><a href=https://s3.amazonaws.com/lambda-tools/pricing-calculator.html>https://s3.amazonaws.com/lambda-tools/pricing-calculator.html</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://novemberde.github.io/tags/apigateway/>apigateway</a></li>
<li><a href=https://novemberde.github.io/tags/lambda/>lambda</a></li>
<li><a href=https://novemberde.github.io/tags/serverless/>serverless</a></li>
<li><a href=https://novemberde.github.io/tags/framework/>framework</a></li>
<li><a href=https://novemberde.github.io/tags/go/>go</a></li>
<li><a href=https://novemberde.github.io/tags/golang/>golang</a></li>
<li><a href=https://novemberde.github.io/tags/go%EC%96%B8%EC%96%B4/>go언어</a></li>
<li><a href=https://novemberde.github.io/tags/coldstart/>coldstart</a></li>
<li><a href=https://novemberde.github.io/tags/cold/>cold</a></li>
<li><a href=https://novemberde.github.io/tags/start/>start</a></li>
<li><a href=https://novemberde.github.io/tags/%EB%AC%B8%EC%A0%9C/>문제</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://novemberde.github.io/post/2018/03/01/Node_apicache/>
<span class=title>« Prev Page</span>
<br>
<span>NODE response를 apicache로 처리하기</span>
</a>
<a class=next href=https://novemberde.github.io/post/2018/01/29/Mysql_maxConnection/>
<span class=title>Next Page »</span>
<br>
<span>AWS Lambda와 MySQL의 max connection 문제</span>
</a>
</nav>
</footer>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//novemberde-github-io.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://novemberde.github.io/>Novemberde's Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>