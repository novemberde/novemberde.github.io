<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>나만의 private docker registry 구성하기. | Novemberde's Blog</title>
<meta name=keywords content="docker,registry,private,ec2,s3">
<meta name=description content="Summary  Docker hub에 private image를 올리는 것은 제한이 있다. 개인 사용자의 경우 하나의 이미지만 private이 가능하고 organization의 경우에는 비용을 지불해야만 사용이 가능하다. 이런점에 비추어 볼 때 우리는 private registry환경을 구축하고 싶다는 생각이 들 것이다.
EC2에 개인 registry를 구축하고 local 또는 다른 서버에서 접근하는 방법에 대해서 진행해보겠다. 그리고 Amazon S3 를 이미지 저장소로 사용하겠다.
Docker registry 구축하기  docker가 설치되어 있는 EC2에 접근하여 registry 이미지를 pull 해보자.
 docker registry의 기본포트는 5000번이다.">
<meta name=author content>
<link rel=canonical href=https://novemberde.github.io/post/2017/04/09/Docker_Registry_0/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.9f1d947375927e9847272b1f4e9be81336f539e513bf04d52cade31f81cad1af.css integrity="sha256-nx2Uc3WSfphHJysfTpvoEzb1OeUTvwTVLK3jH4HK0a8=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://novemberde.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://novemberde.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://novemberde.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://novemberde.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://novemberde.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-97433460-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="나만의 private docker registry 구성하기.">
<meta property="og:description" content="Summary  Docker hub에 private image를 올리는 것은 제한이 있다. 개인 사용자의 경우 하나의 이미지만 private이 가능하고 organization의 경우에는 비용을 지불해야만 사용이 가능하다. 이런점에 비추어 볼 때 우리는 private registry환경을 구축하고 싶다는 생각이 들 것이다.
EC2에 개인 registry를 구축하고 local 또는 다른 서버에서 접근하는 방법에 대해서 진행해보겠다. 그리고 Amazon S3 를 이미지 저장소로 사용하겠다.
Docker registry 구축하기  docker가 설치되어 있는 EC2에 접근하여 registry 이미지를 pull 해보자.
 docker registry의 기본포트는 5000번이다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://novemberde.github.io/post/2017/04/09/Docker_Registry_0/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2017-04-09T11:30:03+00:00">
<meta property="article:modified_time" content="2017-04-09T11:30:03+00:00"><meta property="og:site_name" content="Novemberde dev logs">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="나만의 private docker registry 구성하기.">
<meta name=twitter:description content="Summary  Docker hub에 private image를 올리는 것은 제한이 있다. 개인 사용자의 경우 하나의 이미지만 private이 가능하고 organization의 경우에는 비용을 지불해야만 사용이 가능하다. 이런점에 비추어 볼 때 우리는 private registry환경을 구축하고 싶다는 생각이 들 것이다.
EC2에 개인 registry를 구축하고 local 또는 다른 서버에서 접근하는 방법에 대해서 진행해보겠다. 그리고 Amazon S3 를 이미지 저장소로 사용하겠다.
Docker registry 구축하기  docker가 설치되어 있는 EC2에 접근하여 registry 이미지를 pull 해보자.
 docker registry의 기본포트는 5000번이다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://novemberde.github.io/post/"},{"@type":"ListItem","position":2,"name":"나만의 private docker registry 구성하기.","item":"https://novemberde.github.io/post/2017/04/09/Docker_Registry_0/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"나만의 private docker registry 구성하기.","name":"나만의 private docker registry 구성하기.","description":"Summary  Docker hub에 private image를 올리는 것은 제한이 있다. 개인 사용자의 경우 하나의 이미지만 private이 가능하고 organization의 경우에는 비용을 지불해야만 사용이 가능하다. 이런점에 비추어 볼 때 우리는 private registry환경을 구축하고 싶다는 생각이 들 것이다.\nEC2에 개인 registry를 구축하고 local 또는 다른 서버에서 접근하는 방법에 대해서 진행해보겠다. 그리고 Amazon S3 를 이미지 저장소로 사용하겠다.\nDocker registry 구축하기  docker가 설치되어 있는 EC2에 접근하여 registry 이미지를 pull 해보자.\n docker registry의 기본포트는 5000번이다.","keywords":["docker","registry","private","ec2","s3"],"articleBody":"Summary  Docker hub에 private image를 올리는 것은 제한이 있다. 개인 사용자의 경우 하나의 이미지만 private이 가능하고 organization의 경우에는 비용을 지불해야만 사용이 가능하다. 이런점에 비추어 볼 때 우리는 private registry환경을 구축하고 싶다는 생각이 들 것이다.\nEC2에 개인 registry를 구축하고 local 또는 다른 서버에서 접근하는 방법에 대해서 진행해보겠다. 그리고 Amazon S3 를 이미지 저장소로 사용하겠다.\nDocker registry 구축하기  docker가 설치되어 있는 EC2에 접근하여 registry 이미지를 pull 해보자.\n docker registry의 기본포트는 5000번이다.  # registry 이미지를 가져오기 $ docker pull registry # registry를 실행하기 $ docker run -dit --name docker-registry -p 5000:5000 registry Docker image를 push하기  도커허브를 사용할 때는 /registry:latest 처럼 tag명에 내 아이디가 들어가는 모양이었다. 하지만 private registry를 사용할 때는 부분에 내 registry의 url주소를 사용하여야 한다.\nlocalhost에서 테스트를 진행할테니 localhost:5000/hello-world:latest 이미지를 만들어보자.\n# hello-world 이미지가 없으니 docker hub에서 pull하자. $ docker pull hello-world # localhost/hello-world 이미지를 만들어보자. $ docker tag hello-world localhost:5000/hello-world 이미지를 만들었으니 내 registry에 push하자.\n# 이미지 push하기 $ docker push localhost:5000/hello-world # 이미지 확인하기 $ curl -X GET http://localhost:5000/v2/_catalog # 출력 {\"repositories\":[\"hello-world\"]} # 태그 정보 확인하기 $ curl -X GET http://localhost:5000/v2/hello-world/tags/list # 출력 {\"name\":\"hello-world\",\"tags\":[\"latest\"]} 원격지에서 Docker image를 push하기  지금 이미지의 태그명을 보면 localhost/~ 로 되어 있는 것을 볼 수 있다. 하지만 원격지에서는 특정도메인 또는 IP로 접근하기 때문에 localhost, 127.0.0.1을 사용할 수 없다. gabia, godaddy 또는 AWS 53을 사용하여 DNS설정을 하는 방법과 직접 아이피로 접근해서 등록하는 방법 2가지가 있다.\n이번에는 테스트용 도메인 docker-registry.kh-developer.info 로 DNS를 설정하여 docker registry를 사용하겠다.\ngabia  네임플러스  호스트(IP) 추가/관리 페이지에서 docker-registry를 추가하고 내 EC2 아이피를 할당한다.  아이피를 할당한 후에 현재 pc에서 docker에 push를 해보자.(로컬에도 docker가 설치되어 있어야 한다.) 포트를 5000번으로 registry를 생성했으니 5000번으로 접속하자 EC2에 security group에서 inbound rule에서 5000번으로 설정해주자. my ip를 선택하여 다른 사람이 접근하지 못하도록 하자.  # 현재 이미지 목록 보기. $ docker images # 아직 hello-world가 없으므로 docker pull하기 $ docker pull hello-world # docker-registry.kh-developer.info:5000/hello-world 이미지를 만들어보자. $ docker tag hello-world docker-registry.kh-developer.info:5000/hello-world # 이미지가 생성되었는지 확인해보자. $ docker images # push 해보자. 실패할 것이다. $ docker push docker-registry.kh-developer.info:5000/hello-world 아래와 같은 메시지가 나오면서 실패할 것이다.\nGet https://docker-registry.kh-developer.info:5000/v1/_ping: http: server gave HTTP response to HTTPS client 실패한 이유는 docker registry는 로컬머신에서 사용하는 것이 아니라면 https만 지원을 하기 때문이다. 그럼 원격지에서 접속하기 위해서는 docker registry 설정을 해주어야 한다.\n현재의 docker registry 컨테이너를 내리고 다시 registry를 올려보자.\n# docker registry 컨테이너 내리기 $ docker stop docker-registry \u0026\u0026 docker rm docker-registry SSL 사설 인증서를 발급하자. 종잣돈이 많다면 인증서를 구입해도 괜찮다.\n이번에는 개인 서명 SSL 인증서를 생성하겠다. openssl이 EC2 인스턴스에 설치되어 있을 것이다.\n# openssl 버전 확인하기 $ openssl version # cert.d 폴더에 개인키 생성하기. 비밀번호를 입력하자. 테스트를 위해 개인키 비밀번호는 test로 하겠다. $ mkdir certs \u0026\u0026 cd certs \u0026\u0026 openssl genrsa -des3 -out server.key 2048 # 인증 요청서 생성 $ openssl req -new -key server.key -out server.csr Country Name (2 letter code) [XX]:KR State or Province Name (full name) []:Seoul Locality Name (eg, city) [Default City]:Seongdonggu Organization Name (eg, company) [Default Company Ltd]:NOVEMBERDE Organizational Unit Name (eg, section) []:TEST Common Name (eg, your name or your server\\'s hostname) []:docker-registry.kh-developer.info Email Address []: # 생성된 파일 확인하기 $ ll # 개인키에서 패스워드 제거하기 $ cp server.key server.key.origin \u0026\u0026 openssl rsa -in server.key.origin -out server.key \u0026\u0026 rm server.key.origin # 인증서 생성하기. 1년으로 사용하겠다. 2년 3년할 수도 있다. server.crt파일이 생길 것이다. $ openssl x509 -req -days 730 -in server.csr -signkey server.key -out server.crt 인증서를 발급했으니 registry를 다시 가동해보자.\n$ docker run -d -p 5000:5000 --restart=always --name docker-registry \\  -v /home//certs:/certs \\  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/server.crt \\  -e REGISTRY_HTTP_TLS_KEY=/certs/server.key \\  registry 가동을 성공적으로 마쳤으면 다시 로컬에서 push를 해보자\n# 다시 로컬환경으로 돌아와서 push하기 $ docker push docker-registry.kh-developer.info:5000/hello-world The push refers to a repository [docker-registry.kh-developer.info:5000/hello-world] Get https://docker-registry.kh-developer.info:5000/v1/_ping: x509: certificate signed by unknown authority 위와 같은 메시지가 나오면서 push가 되지 않을 것이다.\n사설인증서이기 때문에 현재 사용하는 PC의 docker가 push하지 못하는 것이다.\nwindows 환경이라면 하단의 상태표시창에서 docker  setting  insecure-registry에서 docker-registry.kh-developer.info 를 설정해주어야 한다.\nkitematic을 사용하고 있다면 아래와 같은 virtual box를 더블클릭하면 콘솔화면이 나타나는데 여기서 /var/lib/boot2docker/profile 파일을 수정해주어야 한다.\nEXTRA_ARGS 에 –insecure-registry를 아래와 같이 추가한다.\n추가 후에 docker를 restart하자.\n 이제 다시 docker push를 해보자. 성공적으로 push가 될 것이다.\n# 다시 로컬환경으로 돌아와서 push하기 $ docker push docker-registry.kh-developer.info:5000/hello-world S3를 저장소로 사용하기  사용하기에 앞서서 AWS에 user를 생성하도록 하자.\nAWS Menu  Security, Identity \u0026 Compliance  IAM 에서 user를 생성한다. username은 docker-registry로 하고, Access type은 Programmatic access로 하자.\n Permission은 Attach existing policies directly로 하여 S3 FullAccess를 선택하여 주자.(FullAccess가 불안하다면 여기를 참고하여 Policy를 생성하길 바란다.)\nCreate를 하면 Access Key와 Secret access key를 부여받는다. 잘 보관하도록 하자.\n docker registry에서 S3에 접근할 수 있도록 설정하자.\n# 기존의 registry를 내려주고, 새로 올리자. $ docker stop docker-registry \u0026\u0026 docker rm docker-registry # 새로 올리기 $ docker run -d -p 5000:5000 --restart=always --name docker-registry \\  -v /home/docker/certs:/certs \\  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/server.crt \\  -e REGISTRY_HTTP_TLS_KEY=/certs/server.key \\  -e REGISTRY_STORAGE=s3 \\  -e REGISTRY_STORAGE_S3_BUCKET=docker-registry.kh-developer \\  -e REGISTRY_STORAGE_S3_ACCESSKEY=ASEFWAF1232REWE \\  -e REGISTRY_STORAGE_S3_SECRETKEY=ASERWER1234WERFASER354SFDSDF1234 \\  -e REGISTRY_STORAGE_S3_REGION=ap-northeast-1 \\  registry # 다시 로컬환경으로 돌아와서 push 해보기 $ docker push docker-registry.kh-developer.info:5000/hello-world S3 bucket을 가면 storage가 형성될 것이다.\nAuthentification 추가하기  여기까지 S3를 이미지 저장소로 사용하는 docker registry를 구성하였다면, 지금부터는 docker registry 접근에 대한 인증절차를 두려고 한다.\n# ~/auth라는 디렉터리에 testuser를 아이디로 갖고 testpassword를 비밀번호로 갖게 해보자. $ mkdir auth \u0026\u0026 docker run --entrypoint htpasswd registry:2 -Bbn testuser testpassword  auth/htpasswd # docker registry container를 다시 실행해보자. $ docker run -d -p 5000:5000 --restart=always --name docker-registry \\  -v /home/docker/certs:/certs \\  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/server.crt \\  -e REGISTRY_HTTP_TLS_KEY=/certs/server.key \\  -e REGISTRY_STORAGE=s3 \\  -e REGISTRY_STORAGE_S3_BUCKET=docker-registry.kh-developer \\  -e REGISTRY_STORAGE_S3_ACCESSKEY=ASEFWAF1232REWE \\  -e REGISTRY_STORAGE_S3_SECRETKEY=ASERWER1234WERFASER354SFDSDF1234 \\  -e REGISTRY_STORAGE_S3_REGION=ap-northeast-1 \\  -v /home/docker/auth:/auth \\  -e \"REGISTRY_AUTH=htpasswd\" \\  -e \"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\" \\  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\  registry # 다시 로컬환경으로 돌아와서 docker push를 해보자 $ docker push docker-registry.kh-developer.info:5000/hello-world 98c944e98de8: Preparing no basic auth credentials 위처럼 auth credentials이 없다고 나온다. docker login을 해주자.\n$ docker login docker-registry.kh-developer.info:5000 Username: testuser Password: Login Succeeded # 로그인이 됐다면 다시 push를 해주자 $ docker push docker-registry.kh-developer.info:5000/hello-world 2018-05-29 추가사항  위에 글을 보면 어렵사리 Docker registry 를 구축하였다. 하지만 살펴보면 곳곳에 문제점이 보일 것이다. 이글을 다시 살펴보면서 정리한 의문점은 다음과 같다.\n 동시에 수십 수백대의 서버가 업데이트를 하는 경우에는 단일 registry 서버로 감당할 수 있을 것인가? 만약 그럴 수 없다면 어떻게 설계해야할까? 이걸 구축하지 않고 편하게 사용할 수 있는 다른 Managed Service는 없을까?  먼저 첫번째 질문에 답을 하자면, docker registry 관련 문서에 다음과 같이 잘 나와 있다.\n Load balancing considerations\nOne may want to use a load balancer to distribute load, terminate TLS or provide high availability. While a full load balancing setup is outside the scope of this document, there are a few considerations that can make the process smoother.\nThe most important aspect is that a load balanced cluster of registries must share the same resources. For the current version of the registry, this means the following must be the same:\nStorage Driver\nHTTP Secret\nRedis Cache (if configured)\nDifferences in any of the above cause problems serving requests. As an example, if you’re using the filesystem driver, all registry instances must have access to the same filesystem root, on the same machine. For other drivers, such as S3 or Azure, they should be accessing the same resource and share an identical configuration. The HTTP Secret coordinates uploads, so also must be the same across instances. Configuring different redis instances works (at the time of writing), but is not optimal if the instances are not shared, because more requests are directed to the backend.\n 출처: https://docs.docker.com/registry/deploying/#load-balancing-considerations\n이 내용을 간단하게 요약하면 다음과 같다. Load balancing을 고려한 설계를 한 경우이다. 웹어플리케이션 설계와 비슷한 방법으로 공통 스토리지는 Storage Driver를 통해 동일 Storage에 접근하도록 하고 Caching을 위해 Redis를 올려놓늗다. 또한 HTTP Secret을 통해 업로드하므로 모든 인스턴스는 동일한 HTTP Secret을 가져야한다.\nCluster를 인스턴스 Auto-scaling하듯이 여러 인스턴스를 배포하고 공통된 Storage에 접근하도록 설정한 다음 배포하면 되는 것이다. 그렇다면 동시에 많은 요청을 감당할 수 있다.\n두번째로 Managed Service를 찾아보았다. docker hub에 Billing plan을 변경하여 private repository를 생성하는 방법이 있다. 또한 AWS ECR을 사용하여 사용하는 저장공간과 네트워크 비용만 지출할 수 있다. 만약 이렇게 비용을 지불하기 싫다면, 배포할 Artifact를 tar로 압축하여 사용할 서버에 던진 다음에 image를 압축해제해서 사용하면 된다. 이러한 방식은 docker save / load 명령어를 통해 사용해볼 수 있다.\n요즘에는 AWS를 기본으로 사용하다보니 docker registry를 올려본지 오래되었다. 그렇지만 처음 내용을 참고하시는 분들이 계신 것 같아, 처음에 글을 쓴 목적과 달리 다른 방법을 사용하는 것을 추천하고 싶다.\ntar로 git hash를 이용하여 versioning하고, 그 다음에 이 tar에 대해서 artifact를 관리하던지, 아니면 Managed service를 활용하여 운영리소스를 줄이는 방법이다. 피치 못할 사정으로 자체 IDC에 docker registry를 올려야 한다면 docker registry를 단일 컨테이너로 올리는 것이 아닌, k8s나 swarm으로 해당 docker registry를 autoscaling group으로 묶어서 배포하면 될 것이다.\nReferences   http://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EA%B0%9C%EC%9D%B8%EC%84%9C%EB%AA%85_SSL_%EC%9D%B8%EC%A6%9D%EC%84%9C_%EC%83%9D%EC%84%B1 https://docs.docker.com/registry/deploying/#lets-encrypt https://docs.docker.com/registry/deploying/#native-basic-auth http://www.notrudebuthonest.com/2016/02/kitematic-enable-insecure-registry/ 별도로 arn에 따라 policy를 주고 싶은 경우는 아래와 같은 policy를 넣어준다.  { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"s3:ListBucket\", \"s3:GetBucketLocation\", \"s3:ListBucketMultipartUploads\" ], \"Resource\": \"arn:aws:s3:::*\" }, { \"Effect\": \"Allow\", \"Action\": [ \"s3:PutObject\", \"s3:GetObject\", \"s3:DeleteObject\", \"s3:ListMultipartUploadParts\", \"s3:AbortMultipartUpload\" ], \"Resource\": \"arn:aws:s3:::S3_BUCKET_NAME/*\" } ] } ","wordCount":"1419","inLanguage":"en","datePublished":"2017-04-09T11:30:03Z","dateModified":"2017-04-09T11:30:03Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://novemberde.github.io/post/2017/04/09/Docker_Registry_0/"},"publisher":{"@type":"Organization","name":"Novemberde's Blog","logo":{"@type":"ImageObject","url":"https://novemberde.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8620431066400094" crossorigin=anonymous></script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://novemberde.github.io/ accesskey=h title="Novemberde's Blog (Alt + H)">Novemberde's Blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://novemberde.github.io/search title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://novemberde.github.io/post/ title=Post>
<span>Post</span>
</a>
</li>
<li>
<a href=https://novemberde.github.io/about title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://novemberde.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://novemberde.github.io/post/>Posts</a></div>
<h1 class=post-title>
나만의 private docker registry 구성하기.
</h1>
<div class=post-meta>April 9, 2017&nbsp;·&nbsp;7 min
</div>
</header>
<div class=post-content><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2>
<hr>
<p>Docker hub에 private image를 올리는 것은 제한이 있다.
개인 사용자의 경우 하나의 이미지만 private이 가능하고 organization의 경우에는 비용을 지불해야만 사용이 가능하다.
이런점에 비추어 볼 때 우리는 private registry환경을 구축하고 싶다는 생각이 들 것이다.</p>
<p>EC2에 개인 registry를 구축하고 local 또는 다른 서버에서 접근하는 방법에 대해서 진행해보겠다. 그리고 Amazon S3 를 이미지 저장소로 사용하겠다.</p>
<h2 id=docker-registry-구축하기>Docker registry 구축하기<a hidden class=anchor aria-hidden=true href=#docker-registry-구축하기>#</a></h2>
<hr>
<p>docker가 설치되어 있는 EC2에 접근하여 registry 이미지를 pull 해보자.</p>
<ul>
<li>docker registry의 기본포트는 5000번이다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># registry 이미지를 가져오기</span>
$ docker pull registry
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># registry를 실행하기</span>
$ docker run -dit --name docker-registry -p 5000:5000 registry
</code></pre></div><h2 id=docker-image를-push하기>Docker image를 push하기<a hidden class=anchor aria-hidden=true href=#docker-image를-push하기>#</a></h2>
<hr>
<p><a href=https://hub.docker.com>도커허브</a>를 사용할 때는 &lt;계정아이디>/registry:latest 처럼 tag명에 내 아이디가 들어가는 모양이었다.
하지만 private registry를 사용할 때는 &lt;계정아이디>부분에 내 registry의 url주소를 사용하여야 한다.</p>
<p>localhost에서 테스트를 진행할테니 localhost:5000/hello-world:latest 이미지를 만들어보자.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># hello-world 이미지가 없으니 docker hub에서 pull하자.</span>
$ docker pull hello-world

<span style=color:#75715e># localhost/hello-world 이미지를 만들어보자.</span>
$ docker tag hello-world localhost:5000/hello-world
</code></pre></div><p>이미지를 만들었으니 내 registry에 push하자.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 이미지 push하기</span>
$ docker push localhost:5000/hello-world

<span style=color:#75715e># 이미지 확인하기</span>
$ curl -X GET http://localhost:5000/v2/_catalog
<span style=color:#75715e># 출력 {&#34;repositories&#34;:[&#34;hello-world&#34;]}</span>

<span style=color:#75715e># 태그 정보 확인하기</span>
$ curl -X GET http://localhost:5000/v2/hello-world/tags/list
<span style=color:#75715e># 출력 {&#34;name&#34;:&#34;hello-world&#34;,&#34;tags&#34;:[&#34;latest&#34;]}</span>
</code></pre></div><h2 id=원격지에서-docker-image를-push하기>원격지에서 Docker image를 push하기<a hidden class=anchor aria-hidden=true href=#원격지에서-docker-image를-push하기>#</a></h2>
<hr>
<p>지금 이미지의 태그명을 보면 localhost/~ 로 되어 있는 것을 볼 수 있다.
하지만 원격지에서는 특정도메인 또는 IP로 접근하기 때문에 localhost, 127.0.0.1을 사용할 수 없다.
gabia, godaddy 또는 AWS 53을 사용하여 DNS설정을 하는 방법과 직접 아이피로 접근해서 등록하는 방법 2가지가 있다.</p>
<p>이번에는 테스트용 도메인 docker-registry.kh-developer.info 로 DNS를 설정하여 docker registry를 사용하겠다.</p>
<p>gabia > 네임플러스 > 호스트(IP) 추가/관리 페이지에서 docker-registry를 추가하고 내 EC2 아이피를 할당한다.
<img loading=lazy src=/images/aws/ec2/gabia.png alt=gabia>
</p>
<ul>
<li>아이피를 할당한 후에 현재 pc에서 docker에 push를 해보자.(로컬에도 docker가 설치되어 있어야 한다.)</li>
<li>포트를 5000번으로 registry를 생성했으니 5000번으로 접속하자</li>
<li>EC2에 security group에서 inbound rule에서 5000번으로 설정해주자. my ip를 선택하여 다른 사람이 접근하지 못하도록 하자.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 현재 이미지 목록 보기.</span>
$ docker images

<span style=color:#75715e># 아직 hello-world가 없으므로 docker pull하기</span>
$ docker pull hello-world

<span style=color:#75715e># docker-registry.kh-developer.info:5000/hello-world 이미지를 만들어보자.</span>
$ docker tag hello-world docker-registry.kh-developer.info:5000/hello-world

<span style=color:#75715e># 이미지가 생성되었는지 확인해보자.</span>
$ docker images

<span style=color:#75715e># push 해보자. 실패할 것이다.</span>
$ docker push docker-registry.kh-developer.info:5000/hello-world
</code></pre></div><p>아래와 같은 메시지가 나오면서 실패할 것이다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>Get https://docker-registry.kh-developer.info:5000/v1/_ping: http: server gave HTTP response to HTTPS client
</code></pre></div><p>실패한 이유는 docker registry는 로컬머신에서 사용하는 것이 아니라면 https만 지원을 하기 때문이다.
그럼 원격지에서 접속하기 위해서는 docker registry 설정을 해주어야 한다.</p>
<p>현재의 docker registry 컨테이너를 내리고 다시 registry를 올려보자.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># docker registry 컨테이너 내리기</span>
$ docker stop docker-registry <span style=color:#f92672>&amp;&amp;</span> docker rm docker-registry
</code></pre></div><p>SSL 사설 인증서를 발급하자. 종잣돈이 많다면 인증서를 구입해도 괜찮다.</p>
<p>이번에는 개인 서명 SSL 인증서를 생성하겠다. openssl이 EC2 인스턴스에 설치되어 있을 것이다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># openssl 버전 확인하기</span>
$ openssl version

<span style=color:#75715e># cert.d 폴더에 개인키 생성하기. 비밀번호를 입력하자. 테스트를 위해 개인키 비밀번호는 test로 하겠다.</span>
$ mkdir certs <span style=color:#f92672>&amp;&amp;</span> cd certs <span style=color:#f92672>&amp;&amp;</span> openssl genrsa -des3 -out server.key <span style=color:#ae81ff>2048</span>

<span style=color:#75715e># 인증 요청서 생성</span>
$ openssl req -new -key server.key -out server.csr

Country Name <span style=color:#f92672>(</span><span style=color:#ae81ff>2</span> letter code<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>XX<span style=color:#f92672>]</span>:KR
State or Province Name <span style=color:#f92672>(</span>full name<span style=color:#f92672>)</span> <span style=color:#f92672>[]</span>:Seoul
Locality Name <span style=color:#f92672>(</span>eg, city<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>Default City<span style=color:#f92672>]</span>:Seongdonggu
Organization Name <span style=color:#f92672>(</span>eg, company<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>Default Company Ltd<span style=color:#f92672>]</span>:NOVEMBERDE
Organizational Unit Name <span style=color:#f92672>(</span>eg, section<span style=color:#f92672>)</span> <span style=color:#f92672>[]</span>:TEST
Common Name <span style=color:#f92672>(</span>eg, your name or your server<span style=color:#ae81ff>\&#39;</span>s hostname<span style=color:#f92672>)</span> <span style=color:#f92672>[]</span>:docker-registry.kh-developer.info
Email Address <span style=color:#f92672>[]</span>:

<span style=color:#75715e># 생성된 파일 확인하기</span>
$ ll

<span style=color:#75715e># 개인키에서 패스워드 제거하기</span>
$ cp server.key server.key.origin <span style=color:#f92672>&amp;&amp;</span> openssl rsa -in server.key.origin -out server.key <span style=color:#f92672>&amp;&amp;</span> rm server.key.origin

<span style=color:#75715e># 인증서 생성하기. 1년으로 사용하겠다. 2년 3년할 수도 있다. server.crt파일이 생길 것이다.</span>
$ openssl x509 -req -days <span style=color:#ae81ff>730</span> -in server.csr -signkey server.key -out server.crt
</code></pre></div><p>인증서를 발급했으니 registry를 다시 가동해보자.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker run -d -p 5000:5000 --restart<span style=color:#f92672>=</span>always --name docker-registry <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -v /home/&lt;username&gt;/certs:/certs <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_HTTP_TLS_CERTIFICATE<span style=color:#f92672>=</span>/certs/server.crt <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_HTTP_TLS_KEY<span style=color:#f92672>=</span>/certs/server.key <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  registry
</code></pre></div><p>가동을 성공적으로 마쳤으면 다시 로컬에서 push를 해보자</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 다시 로컬환경으로 돌아와서 push하기</span>
$ docker push docker-registry.kh-developer.info:5000/hello-world

The push refers to a repository <span style=color:#f92672>[</span>docker-registry.kh-developer.info:5000/hello-world<span style=color:#f92672>]</span>
Get https://docker-registry.kh-developer.info:5000/v1/_ping: x509: certificate signed by unknown authority
</code></pre></div><p>위와 같은 메시지가 나오면서 push가 되지 않을 것이다.</p>
<p>사설인증서이기 때문에 현재 사용하는 PC의 docker가 push하지 못하는 것이다.</p>
<p>windows 환경이라면 하단의 상태표시창에서 docker > setting > insecure-registry에서 docker-registry.kh-developer.info 를 설정해주어야 한다.</p>
<p>kitematic을 사용하고 있다면 아래와 같은 virtual box를 더블클릭하면 콘솔화면이 나타나는데 여기서 /var/lib/boot2docker/profile 파일을 수정해주어야 한다.</p>
<p>EXTRA_ARGS 에 &ndash;insecure-registry를 아래와 같이 추가한다.</p>
<p><img loading=lazy src=/images/aws/ec2/virtual_box.png alt=virtual_box>
</p>
<p>추가 후에 docker를 restart하자.</p>
<hr>
<p>이제 다시 docker push를 해보자. 성공적으로 push가 될 것이다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 다시 로컬환경으로 돌아와서 push하기</span>
$ docker push docker-registry.kh-developer.info:5000/hello-world
</code></pre></div><h3 id=s3를-저장소로-사용하기>S3를 저장소로 사용하기<a hidden class=anchor aria-hidden=true href=#s3를-저장소로-사용하기>#</a></h3>
<hr>
<p>사용하기에 앞서서 AWS에 user를 생성하도록 하자.</p>
<p>AWS Menu > Security, Identity & Compliance > IAM 에서 user를 생성한다.
username은 docker-registry로 하고, Access type은 Programmatic access로 하자.</p>
<p><img loading=lazy src=/images/aws/ec2/add_user.png alt=add_user>
</p>
<hr>
<p>Permission은 Attach existing policies directly로 하여 S3 FullAccess를 선택하여 주자.(FullAccess가 불안하다면 <a href=https://docs.docker.com/registry/storage-drivers/s3/#s3-permission-scopes>여기</a>를 참고하여 Policy를 생성하길 바란다.)</p>
<p>Create를 하면 Access Key와 Secret access key를 부여받는다. 잘 보관하도록 하자.</p>
<hr>
<p>docker registry에서 S3에 접근할 수 있도록 설정하자.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 기존의 registry를 내려주고, 새로 올리자.</span>
$ docker stop docker-registry <span style=color:#f92672>&amp;&amp;</span> docker rm docker-registry

<span style=color:#75715e># 새로 올리기</span>
$ docker run -d -p 5000:5000 --restart<span style=color:#f92672>=</span>always --name docker-registry <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -v /home/docker/certs:/certs <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_HTTP_TLS_CERTIFICATE<span style=color:#f92672>=</span>/certs/server.crt <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_HTTP_TLS_KEY<span style=color:#f92672>=</span>/certs/server.key <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_STORAGE<span style=color:#f92672>=</span>s3 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_STORAGE_S3_BUCKET<span style=color:#f92672>=</span>docker-registry.kh-developer <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_STORAGE_S3_ACCESSKEY<span style=color:#f92672>=</span>ASEFWAF1232REWE <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_STORAGE_S3_SECRETKEY<span style=color:#f92672>=</span>ASERWER1234WERFASER354SFDSDF1234 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_STORAGE_S3_REGION<span style=color:#f92672>=</span>ap-northeast-1 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  registry

<span style=color:#75715e># 다시 로컬환경으로 돌아와서 push 해보기</span>
$ docker push docker-registry.kh-developer.info:5000/hello-world
</code></pre></div><p>S3 bucket을 가면 storage가 형성될 것이다.</p>
<h3 id=authentification-추가하기>Authentification 추가하기<a hidden class=anchor aria-hidden=true href=#authentification-추가하기>#</a></h3>
<hr>
<p>여기까지 S3를 이미지 저장소로 사용하는 docker registry를 구성하였다면, 지금부터는 docker registry 접근에 대한 인증절차를 두려고 한다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># ~/auth라는 디렉터리에 testuser를 아이디로 갖고 testpassword를 비밀번호로 갖게 해보자.</span>
$ mkdir auth <span style=color:#f92672>&amp;&amp;</span> docker run --entrypoint htpasswd registry:2 -Bbn testuser testpassword &gt; auth/htpasswd


<span style=color:#75715e># docker registry container를 다시 실행해보자.</span>
$ docker run -d -p 5000:5000 --restart<span style=color:#f92672>=</span>always --name docker-registry <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -v /home/docker/certs:/certs <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_HTTP_TLS_CERTIFICATE<span style=color:#f92672>=</span>/certs/server.crt <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_HTTP_TLS_KEY<span style=color:#f92672>=</span>/certs/server.key <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_STORAGE<span style=color:#f92672>=</span>s3 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_STORAGE_S3_BUCKET<span style=color:#f92672>=</span>docker-registry.kh-developer <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_STORAGE_S3_ACCESSKEY<span style=color:#f92672>=</span>ASEFWAF1232REWE <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_STORAGE_S3_SECRETKEY<span style=color:#f92672>=</span>ASERWER1234WERFASER354SFDSDF1234 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_STORAGE_S3_REGION<span style=color:#f92672>=</span>ap-northeast-1 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -v /home/docker/auth:/auth <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e <span style=color:#e6db74>&#34;REGISTRY_AUTH=htpasswd&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e <span style=color:#e6db74>&#34;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -e REGISTRY_AUTH_HTPASSWD_PATH<span style=color:#f92672>=</span>/auth/htpasswd <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  registry

<span style=color:#75715e># 다시 로컬환경으로 돌아와서 docker push를 해보자</span>
$ docker push docker-registry.kh-developer.info:5000/hello-world
98c944e98de8: Preparing
no basic auth credentials
</code></pre></div><p>위처럼 auth credentials이 없다고 나온다. docker login을 해주자.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker login docker-registry.kh-developer.info:5000
Username: testuser
Password:
Login Succeeded

<span style=color:#75715e># 로그인이 됐다면 다시 push를 해주자</span>
$ docker push docker-registry.kh-developer.info:5000/hello-world
</code></pre></div><h3 id=2018-05-29-추가사항>2018-05-29 추가사항<a hidden class=anchor aria-hidden=true href=#2018-05-29-추가사항>#</a></h3>
<hr>
<p>위에 글을 보면 어렵사리 Docker registry 를 구축하였다. 하지만 살펴보면 곳곳에 문제점이 보일 것이다.
이글을 다시 살펴보면서 정리한 의문점은 다음과 같다.</p>
<ol>
<li>동시에 수십 수백대의 서버가 업데이트를 하는 경우에는 단일 registry 서버로 감당할 수 있을 것인가? 만약 그럴 수 없다면 어떻게 설계해야할까?</li>
<li>이걸 구축하지 않고 편하게 사용할 수 있는 다른 Managed Service는 없을까?</li>
</ol>
<p>먼저 첫번째 질문에 답을 하자면, docker registry 관련 문서에 다음과 같이 잘 나와 있다.</p>
<blockquote>
<p>Load balancing considerations</p>
<p>One may want to use a load balancer to distribute load, terminate TLS or provide high availability. While a full load balancing setup is outside the scope of this document, there are a few considerations that can make the process smoother.</p>
<p>The most important aspect is that a load balanced cluster of registries must share the same resources. For the current version of the registry, this means the following must be the same:</p>
<p>Storage Driver</p>
<p>HTTP Secret</p>
<p>Redis Cache (if configured)</p>
<p>Differences in any of the above cause problems serving requests. As an example, if you’re using the filesystem driver, all registry instances must have access to the same filesystem root, on the same machine. For other drivers, such as S3 or Azure, they should be accessing the same resource and share an identical configuration. The HTTP Secret coordinates uploads, so also must be the same across instances. Configuring different redis instances works (at the time of writing), but is not optimal if the instances are not shared, because more requests are directed to the backend.</p>
</blockquote>
<p><a href=https://docs.docker.com/registry/deploying/#load-balancing-considerations>출처: https://docs.docker.com/registry/deploying/#load-balancing-considerations</a></p>
<p>이 내용을 간단하게 요약하면 다음과 같다.
Load balancing을 고려한 설계를 한 경우이다. 웹어플리케이션 설계와 비슷한 방법으로 공통 스토리지는 Storage Driver를 통해 동일 Storage에 접근하도록 하고 Caching을 위해 Redis를 올려놓늗다. 또한 HTTP Secret을 통해 업로드하므로 모든 인스턴스는 동일한 HTTP Secret을 가져야한다.</p>
<p>Cluster를 인스턴스 Auto-scaling하듯이 여러 인스턴스를 배포하고 공통된 Storage에 접근하도록 설정한 다음 배포하면 되는 것이다. 그렇다면 동시에 많은 요청을 감당할 수 있다.</p>
<p>두번째로 Managed Service를 찾아보았다.
docker hub에 Billing plan을 변경하여 private repository를 생성하는 방법이 있다.
또한 AWS ECR을 사용하여 사용하는 저장공간과 네트워크 비용만 지출할 수 있다.
만약 이렇게 비용을 지불하기 싫다면, 배포할 Artifact를 tar로 압축하여
사용할 서버에 던진 다음에 image를 압축해제해서 사용하면 된다.
이러한 방식은 docker save / load 명령어를 통해 사용해볼 수 있다.</p>
<p>요즘에는 AWS를 기본으로 사용하다보니 docker registry를 올려본지 오래되었다.
그렇지만 처음 내용을 참고하시는 분들이 계신 것 같아, 처음에 글을 쓴 목적과 달리 다른 방법을 사용하는 것을 추천하고 싶다.</p>
<p>tar로 git hash를 이용하여 versioning하고, 그 다음에 이 tar에 대해서 artifact를 관리하던지,
아니면 Managed service를 활용하여 운영리소스를 줄이는 방법이다.
피치 못할 사정으로 자체 IDC에 docker registry를 올려야 한다면 docker registry를 단일 컨테이너로 올리는 것이 아닌,
k8s나 swarm으로 해당 docker registry를 autoscaling group으로 묶어서 배포하면 될 것이다.</p>
<h3 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h3>
<hr>
<ul>
<li><a href=http://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EA%B0%9C%EC%9D%B8%EC%84%9C%EB%AA%85_SSL_%EC%9D%B8%EC%A6%9D%EC%84%9C_%EC%83%9D%EC%84%B1>http://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EA%B0%9C%EC%9D%B8%EC%84%9C%EB%AA%85_SSL_%EC%9D%B8%EC%A6%9D%EC%84%9C_%EC%83%9D%EC%84%B1</a></li>
<li><a href=https://docs.docker.com/registry/deploying/#lets-encrypt>https://docs.docker.com/registry/deploying/#lets-encrypt</a></li>
<li><a href>https://docs.docker.com/registry/deploying/#native-basic-auth</a></li>
<li><a href=http://www.notrudebuthonest.com/2016/02/kitematic-enable-insecure-registry/>http://www.notrudebuthonest.com/2016/02/kitematic-enable-insecure-registry/</a></li>
<li>별도로 arn에 따라 policy를 주고 싶은 경우는 아래와 같은 policy를 넣어준다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:#f92672>&#34;Version&#34;</span>: <span style=color:#e6db74>&#34;2012-10-17&#34;</span>,
    <span style=color:#f92672>&#34;Statement&#34;</span>: [
        {
            <span style=color:#f92672>&#34;Effect&#34;</span>: <span style=color:#e6db74>&#34;Allow&#34;</span>,
            <span style=color:#f92672>&#34;Action&#34;</span>: [
                <span style=color:#e6db74>&#34;s3:ListBucket&#34;</span>,
                <span style=color:#e6db74>&#34;s3:GetBucketLocation&#34;</span>,
                <span style=color:#e6db74>&#34;s3:ListBucketMultipartUploads&#34;</span>
            ],
            <span style=color:#f92672>&#34;Resource&#34;</span>: <span style=color:#e6db74>&#34;arn:aws:s3:::*&#34;</span>
        },
        {
            <span style=color:#f92672>&#34;Effect&#34;</span>: <span style=color:#e6db74>&#34;Allow&#34;</span>,
            <span style=color:#f92672>&#34;Action&#34;</span>: [
                <span style=color:#e6db74>&#34;s3:PutObject&#34;</span>,
                <span style=color:#e6db74>&#34;s3:GetObject&#34;</span>,
                <span style=color:#e6db74>&#34;s3:DeleteObject&#34;</span>,
                <span style=color:#e6db74>&#34;s3:ListMultipartUploadParts&#34;</span>,
                <span style=color:#e6db74>&#34;s3:AbortMultipartUpload&#34;</span>
            ],
            <span style=color:#f92672>&#34;Resource&#34;</span>: <span style=color:#e6db74>&#34;arn:aws:s3:::S3_BUCKET_NAME/*&#34;</span>
        }
    ]
}
</code></pre></div>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://novemberde.github.io/tags/docker/>docker</a></li>
<li><a href=https://novemberde.github.io/tags/registry/>registry</a></li>
<li><a href=https://novemberde.github.io/tags/private/>private</a></li>
<li><a href=https://novemberde.github.io/tags/ec2/>ec2</a></li>
<li><a href=https://novemberde.github.io/tags/s3/>s3</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://novemberde.github.io/post/2017/04/15/String_0/>
<span class=title>« Prev Page</span>
<br>
<span>Java에서 String, StringBuilder, StringBuffer의 차이</span>
</a>
<a class=next href=https://novemberde.github.io/post/2017/04/03/Docker_9/>
<span class=title>Next Page »</span>
<br>
<span>만들어진 Docker image를 EC2 인스턴스에 배포하기</span>
</a>
</nav>
</footer>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//novemberde-github-io.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://novemberde.github.io/>Novemberde's Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>