<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Sequelize에서 parallel execution과 serial execution | Novemberde's Blog</title>
<meta name=keywords content="nodejs,sequelize,Promise,parallel,execution"><meta name=description content="Summary node js로 서버를 구성할 때 ORM framework로 sequelize를 사용한다. 하지만 비동기로 모든 CRUD가 진행되다보니 동시에 여러 쿼리문의 결과가 요구될 때도 있다. serial execution과 parallel execution을 살표보자.
parallel execution과 serial execution Promise pattern을 활용하여 절차적으로 함수를 실행하면 여러 트랜잭션 과정을 파악하기 쉽다. callback 패턴의 늪에서 벗어날 수 있는 Promise는 현재 서버사이드에서 사용되는 라이브러리들에서 적극 활용되어지고 있다.
먼저 serial execution을 살펴보고 이에 대한 단점도 파악해 보자.
아래의 예제는 User를 검색하고 관계가 형성되어 있지 않은 다른 테이블을 Select하는 경우이다."><meta name=author content><link rel=canonical href=https://novemberde.github.io/post/2017/07/01/Sequelize_0/><link crossorigin=anonymous href=/assets/css/stylesheet.min.9f1d947375927e9847272b1f4e9be81336f539e513bf04d52cade31f81cad1af.css integrity="sha256-nx2Uc3WSfphHJysfTpvoEzb1OeUTvwTVLK3jH4HK0a8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://novemberde.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://novemberde.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://novemberde.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://novemberde.github.io/apple-touch-icon.png><link rel=mask-icon href=https://novemberde.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.122.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9SF4VDQ4N0"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9SF4VDQ4N0",{anonymize_ip:!1})}</script><meta property="og:title" content="Sequelize에서 parallel execution과 serial execution"><meta property="og:description" content="Summary node js로 서버를 구성할 때 ORM framework로 sequelize를 사용한다. 하지만 비동기로 모든 CRUD가 진행되다보니 동시에 여러 쿼리문의 결과가 요구될 때도 있다. serial execution과 parallel execution을 살표보자.
parallel execution과 serial execution Promise pattern을 활용하여 절차적으로 함수를 실행하면 여러 트랜잭션 과정을 파악하기 쉽다. callback 패턴의 늪에서 벗어날 수 있는 Promise는 현재 서버사이드에서 사용되는 라이브러리들에서 적극 활용되어지고 있다.
먼저 serial execution을 살펴보고 이에 대한 단점도 파악해 보자.
아래의 예제는 User를 검색하고 관계가 형성되어 있지 않은 다른 테이블을 Select하는 경우이다."><meta property="og:type" content="article"><meta property="og:url" content="https://novemberde.github.io/post/2017/07/01/Sequelize_0/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-07-01T13:30:03+00:00"><meta property="article:modified_time" content="2017-07-01T13:30:03+00:00"><meta property="og:site_name" content="Novemberde dev logs"><meta name=twitter:card content="summary"><meta name=twitter:title content="Sequelize에서 parallel execution과 serial execution"><meta name=twitter:description content="Summary node js로 서버를 구성할 때 ORM framework로 sequelize를 사용한다. 하지만 비동기로 모든 CRUD가 진행되다보니 동시에 여러 쿼리문의 결과가 요구될 때도 있다. serial execution과 parallel execution을 살표보자.
parallel execution과 serial execution Promise pattern을 활용하여 절차적으로 함수를 실행하면 여러 트랜잭션 과정을 파악하기 쉽다. callback 패턴의 늪에서 벗어날 수 있는 Promise는 현재 서버사이드에서 사용되는 라이브러리들에서 적극 활용되어지고 있다.
먼저 serial execution을 살펴보고 이에 대한 단점도 파악해 보자.
아래의 예제는 User를 검색하고 관계가 형성되어 있지 않은 다른 테이블을 Select하는 경우이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://novemberde.github.io/post/"},{"@type":"ListItem","position":2,"name":"Sequelize에서 parallel execution과 serial execution","item":"https://novemberde.github.io/post/2017/07/01/Sequelize_0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Sequelize에서 parallel execution과 serial execution","name":"Sequelize에서 parallel execution과 serial execution","description":"Summary node js로 서버를 구성할 때 ORM framework로 sequelize를 사용한다. 하지만 비동기로 모든 CRUD가 진행되다보니 동시에 여러 쿼리문의 결과가 요구될 때도 있다. serial execution과 parallel execution을 살표보자.\nparallel execution과 serial execution Promise pattern을 활용하여 절차적으로 함수를 실행하면 여러 트랜잭션 과정을 파악하기 쉽다. callback 패턴의 늪에서 벗어날 수 있는 Promise는 현재 서버사이드에서 사용되는 라이브러리들에서 적극 활용되어지고 있다.\n먼저 serial execution을 살펴보고 이에 대한 단점도 파악해 보자.\n아래의 예제는 User를 검색하고 관계가 형성되어 있지 않은 다른 테이블을 Select하는 경우이다.","keywords":["nodejs","sequelize","Promise","parallel","execution"],"articleBody":"Summary node js로 서버를 구성할 때 ORM framework로 sequelize를 사용한다. 하지만 비동기로 모든 CRUD가 진행되다보니 동시에 여러 쿼리문의 결과가 요구될 때도 있다. serial execution과 parallel execution을 살표보자.\nparallel execution과 serial execution Promise pattern을 활용하여 절차적으로 함수를 실행하면 여러 트랜잭션 과정을 파악하기 쉽다. callback 패턴의 늪에서 벗어날 수 있는 Promise는 현재 서버사이드에서 사용되는 라이브러리들에서 적극 활용되어지고 있다.\n먼저 serial execution을 살펴보고 이에 대한 단점도 파악해 보자.\n아래의 예제는 User를 검색하고 관계가 형성되어 있지 않은 다른 테이블을 Select하는 경우이다.\n// Serial execution let users; let menus; models.User.findAll({ attributes: ['id', 'name', 'phone', 'address'] }) .then( result =\u003e { if (!result) throw new Error(\"Not Found\"); users = result; return models.Menu.findAll() }) .then( result =\u003e { if (!result) throw new Error(\"Not Found\"); menus = result; console.log(users); console.log(menus); }); 이를 살펴보면 조금 이상한 점이 있다. 하나의 결과를 받고 그 다음에 또 다시 쿼리를 실행하는 느낌이다. 서로 관계없는 데이터이기 때문에 두개의 쿼리를 동시에 보내고 따로 값을 받아서 처리하는게 나아보인다. 왜냐하면 절차적으로 반드시 이렇게 이루어져야만 하는 쿼리가 아니기 때문이다.\n만약 하나의 값을 select해서 insert하는 경우라면 사용할 수 있겠지만 위의 경우는 상관관계가 없기 때문이다.\n그렇다면 어떻게 사용할 수 있을까?\nPromise.all() 함수를 사용하면 간단히 해결할 수 있다.\n// Serial execution let users; let menus; Promise.all([ models.User.findAll({ attributes: ['id', 'name', 'phone', 'address'] }), models.Menu.findAll() ]) .then( result =\u003e { if (!result[0]) throw new Error(\"Not Found\"); if (!result[1]) throw new Error(\"Not Found\"); users = result; menus = result; console.log(users); console.log(menus); }); 위 뿐만아니라 하나의 transaction이 일어나는 과정에서 여러 데이터를 CRUD하는 경우에도 유용하게 사용될 수 있다.\n이처럼 Promise는 비동기적으로 일어나는 과정을 간단히 표현할 수 있다. 모든 이벤트가 종료되었을 때 then절이 동작하기 때문에 코드가 난잡해지는 것을 방지하기 때문이다.\nPromise 패턴이 javascript에서 많은 변화를 가져왔다. 최근에는 Async/Await가 사용되는데 nodejs 8 version이후부터 사용 가능하다고 한다.\n비동기 패턴에 대해 더욱 공부하고 싶으신 분들은 Async/Await에 대해 찾아보길 바란다.\nReferences http://docs.sequelizejs.com/manual/tutorial/transactions.html https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise ","wordCount":"293","inLanguage":"en","datePublished":"2017-07-01T13:30:03Z","dateModified":"2017-07-01T13:30:03Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://novemberde.github.io/post/2017/07/01/Sequelize_0/"},"publisher":{"@type":"Organization","name":"Novemberde's Blog","logo":{"@type":"ImageObject","url":"https://novemberde.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8620431066400094" crossorigin=anonymous></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://novemberde.github.io/ accesskey=h title="Novemberde's Blog (Alt + H)">Novemberde's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://novemberde.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://novemberde.github.io/post/ title=Post><span>Post</span></a></li><li><a href=https://novemberde.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://novemberde.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://novemberde.github.io/post/>Posts</a></div><h1 class=post-title>Sequelize에서 parallel execution과 serial execution</h1><div class=post-meta>July 1, 2017 2 min</div></header><div class=post-content><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><hr><p>node js로 서버를 구성할 때 ORM framework로 sequelize를 사용한다.
하지만 비동기로 모든 CRUD가 진행되다보니 동시에 여러 쿼리문의 결과가 요구될 때도 있다.
serial execution과 parallel execution을 살표보자.</p><hr><h3 id=parallel-execution과-serial-execution>parallel execution과 serial execution<a hidden class=anchor aria-hidden=true href=#parallel-execution과-serial-execution>#</a></h3><hr><p>Promise pattern을 활용하여 절차적으로 함수를 실행하면 여러 트랜잭션 과정을 파악하기 쉽다.
callback 패턴의 늪에서 벗어날 수 있는 Promise는 현재 서버사이드에서 사용되는 라이브러리들에서
적극 활용되어지고 있다.</p><p>먼저 serial execution을 살펴보고 이에 대한 단점도 파악해 보자.</p><p>아래의 예제는 User를 검색하고 관계가 형성되어 있지 않은 다른 테이블을 Select하는 경우이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Serial execution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>users</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>menus</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>models</span>.<span style=color:#a6e22e>User</span>.<span style=color:#a6e22e>findAll</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>attributes</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;id&#39;</span>, <span style=color:#e6db74>&#39;name&#39;</span>, <span style=color:#e6db74>&#39;phone&#39;</span>, <span style=color:#e6db74>&#39;address&#39;</span>]
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>then</span>( <span style=color:#a6e22e>result</span> =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>result</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;Not Found&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>users</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>result</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>models</span>.<span style=color:#a6e22e>Menu</span>.<span style=color:#a6e22e>findAll</span>()
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>then</span>( <span style=color:#a6e22e>result</span> =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>result</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;Not Found&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>menus</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>result</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>users</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>menus</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>이를 살펴보면 조금 이상한 점이 있다. 하나의 결과를 받고 그 다음에 또 다시 쿼리를 실행하는 느낌이다.
서로 관계없는 데이터이기 때문에 두개의 쿼리를 동시에 보내고 따로 값을 받아서 처리하는게 나아보인다.
왜냐하면 절차적으로 반드시 이렇게 이루어져야만 하는 쿼리가 아니기 때문이다.</p><p>만약 하나의 값을 select해서 insert하는 경우라면 사용할 수 있겠지만 위의 경우는 상관관계가 없기 때문이다.</p><p>그렇다면 어떻게 사용할 수 있을까?</p><p>Promise.all() 함수를 사용하면 간단히 해결할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Serial execution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>users</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>menus</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Promise.<span style=color:#a6e22e>all</span>([
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>models</span>.<span style=color:#a6e22e>User</span>.<span style=color:#a6e22e>findAll</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>attributes</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;id&#39;</span>, <span style=color:#e6db74>&#39;name&#39;</span>, <span style=color:#e6db74>&#39;phone&#39;</span>, <span style=color:#e6db74>&#39;address&#39;</span>]
</span></span><span style=display:flex><span>    }),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>models</span>.<span style=color:#a6e22e>Menu</span>.<span style=color:#a6e22e>findAll</span>()
</span></span><span style=display:flex><span>])
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>then</span>( <span style=color:#a6e22e>result</span> =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>result</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;Not Found&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>result</span>[<span style=color:#ae81ff>1</span>]) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;Not Found&#34;</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>users</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>result</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>menus</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>result</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>users</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>menus</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>위 뿐만아니라 하나의 transaction이 일어나는 과정에서 여러 데이터를 CRUD하는 경우에도 유용하게 사용될 수 있다.</p><p>이처럼 Promise는 비동기적으로 일어나는 과정을 간단히 표현할 수 있다.
모든 이벤트가 종료되었을 때 then절이 동작하기 때문에 코드가 난잡해지는 것을 방지하기 때문이다.</p><p>Promise 패턴이 javascript에서 많은 변화를 가져왔다.
최근에는 Async/Await가 사용되는데 nodejs 8 version이후부터 사용 가능하다고 한다.</p><p>비동기 패턴에 대해 더욱 공부하고 싶으신 분들은 Async/Await에 대해 찾아보길 바란다.</p><hr><h3 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h3><hr><ul><li><a href=http://docs.sequelizejs.com/manual/tutorial/transactions.html>http://docs.sequelizejs.com/manual/tutorial/transactions.html</a></li><li><a href=https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise>https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://novemberde.github.io/tags/nodejs/>nodejs</a></li><li><a href=https://novemberde.github.io/tags/sequelize/>sequelize</a></li><li><a href=https://novemberde.github.io/tags/Promise/>Promise</a></li><li><a href=https://novemberde.github.io/tags/parallel/>parallel</a></li><li><a href=https://novemberde.github.io/tags/execution/>execution</a></li></ul><nav class=paginav><a class=prev href=https://novemberde.github.io/post/2017/07/03/Elastic_Beanstalk/><span class=title>« Prev Page</span><br><span>Docker image를 EB(Elastic Beanstalk)를 통해 배포하기</span>
</a><a class=next href=https://novemberde.github.io/post/2017/07/01/Mongodb_transport/><span class=title>Next Page »</span><br><span>다른 서버로 Mongodb 이전하기</span></a></nav></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//novemberde-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://novemberde.github.io/>Novemberde's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>