<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>execution on Novemberde&#39;s Blog</title>
    <link>https://novemberde.github.io/tags/execution/</link>
    <description>Recent content in execution on Novemberde&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Sat, 01 Jul 2017 13:30:03 +0000</lastBuildDate><atom:link href="https://novemberde.github.io/tags/execution/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sequelize에서 parallel execution과 serial execution</title>
      <link>https://novemberde.github.io/post/2017/07/01/Sequelize_0/</link>
      <pubDate>Sat, 01 Jul 2017 13:30:03 +0000</pubDate>
      
      <guid>https://novemberde.github.io/post/2017/07/01/Sequelize_0/</guid>
      <description>Summary  node js로 서버를 구성할 때 ORM framework로 sequelize를 사용한다. 하지만 비동기로 모든 CRUD가 진행되다보니 동시에 여러 쿼리문의 결과가 요구될 때도 있다. serial execution과 parallel execution을 살표보자.
 parallel execution과 serial execution  Promise pattern을 활용하여 절차적으로 함수를 실행하면 여러 트랜잭션 과정을 파악하기 쉽다. callback 패턴의 늪에서 벗어날 수 있는 Promise는 현재 서버사이드에서 사용되는 라이브러리들에서 적극 활용되어지고 있다.
먼저 serial execution을 살펴보고 이에 대한 단점도 파악해 보자.
아래의 예제는 User를 검색하고 관계가 형성되어 있지 않은 다른 테이블을 Select하는 경우이다.</description>
    </item>
    
  </channel>
</rss>
