<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Database on Novemberde&#39;s Blog</title>
    <link>https://novemberde.github.io/tags/database/</link>
    <description>Recent content in Database on Novemberde&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Mon, 21 Oct 2024 09:30:00 +0000</lastBuildDate><atom:link href="https://novemberde.github.io/tags/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AppWrite vs. Supabase: A Comprehensive Comparison</title>
      <link>https://novemberde.github.io/post/2024/10/21/appwrite-vs-supabaes/</link>
      <pubDate>Mon, 21 Oct 2024 09:30:00 +0000</pubDate>
      
      <guid>https://novemberde.github.io/post/2024/10/21/appwrite-vs-supabaes/</guid>
      <description>&lt;h1 id=&#34;appwrite-vs-supabase-a-comprehensive-comparison&#34;&gt;AppWrite vs. Supabase: A Comprehensive Comparison&lt;/h1&gt;
&lt;p&gt;It&amp;rsquo;s difficult to definitively say one is &amp;ldquo;better&amp;rdquo; than the other, as each has its strengths and is suited for different use cases. However, I can provide a comparison of their key features and performance to help you make an informed decision:&lt;/p&gt;
&lt;h2 id=&#34;performance-and-scalability&#34;&gt;Performance and Scalability&lt;/h2&gt;
&lt;p&gt;Appwrite consistently outperformed Supabase in stress tests, especially when scaling up to handle more users[1][4]. For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On a €5/month self-hosted server, Appwrite handled up to 2,000 users per day comfortably, while Supabase struggled with larger loads[1].&lt;/li&gt;
&lt;li&gt;On a more powerful €30/month server, Appwrite managed up to 250 simultaneous users, while Supabase hit its limit at only 45 users[1].&lt;/li&gt;
&lt;li&gt;In breakpoint tests, Appwrite reached 6,800 virtual users, processing 100,000 requests with an average 3-second response time. Supabase reached its breakpoint at 3,000 virtual users, with 59,000 requests and a 6-second average response time[4].&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ease-of-use&#34;&gt;Ease of Use&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Appwrite offers a smoother self-hosting experience with fewer restrictions and less setup complexity[1][3].&lt;/li&gt;
&lt;li&gt;Supabase can be more challenging to configure in a self-hosted environment and has some features restricted or limited when self-hosted[1][3].&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;
&lt;p&gt;Both platforms offer similar core features, including authentication, databases, storage, and serverless functions. However, there are some differences:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PostgreSQL Connection Modes(Session Mode vs. Transaction Mode)</title>
      <link>https://novemberde.github.io/post/2024/10/21/postgres-connection-mode-session-mode/</link>
      <pubDate>Mon, 21 Oct 2024 08:30:00 +0000</pubDate>
      
      <guid>https://novemberde.github.io/post/2024/10/21/postgres-connection-mode-session-mode/</guid>
      <description>&lt;h2 id=&#34;connection-mode-session-mode&#34;&gt;Connection Mode (Session Mode)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Each client maintains a dedicated connection to the database for the entire session duration[2].&lt;/li&gt;
&lt;li&gt;The connection is only released back to the pool when the client disconnects from the database[2].&lt;/li&gt;
&lt;li&gt;This mode replicates a direct connection to PostgreSQL and supports all PostgreSQL features and mechanisms[2].&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s safer and more compatible with all PostgreSQL clients[2].&lt;/li&gt;
&lt;li&gt;Does not significantly reduce the load on database resources[2].&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;transaction-mode&#34;&gt;Transaction Mode&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The connection to PostgreSQL is maintained only for the duration of a transaction[2].&lt;/li&gt;
&lt;li&gt;When the transaction completes, the connection is returned to the pool and can be reused by other clients[2].&lt;/li&gt;
&lt;li&gt;Allows for a higher number of client connections (up to 10,000) with a smaller pool size[2].&lt;/li&gt;
&lt;li&gt;Reduces the load on DBMS resources, especially beneficial for a large number of low-load client connections[2].&lt;/li&gt;
&lt;li&gt;More efficient in terms of resource utilization, as idle connections are released back to the pool[3].&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;key-differences&#34;&gt;Key Differences&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Connection Duration&lt;/strong&gt;:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RDS PostgreSQL에서 Aurora PostgreSQL Migration 하기</title>
      <link>https://novemberde.github.io/post/2020/10/17/RDS-to-aurora/</link>
      <pubDate>Sat, 17 Oct 2020 11:30:03 +0000</pubDate>
      
      <guid>https://novemberde.github.io/post/2020/10/17/RDS-to-aurora/</guid>
      <description>&lt;p&gt;RDS PostgreSQL에서 Aurora PostgreSQL을 도입한 후기&lt;/p&gt;
&lt;h2 id=&#34;presentation&#34;&gt;Presentation&lt;/h2&gt;
&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/MF3vow5382w3nT&#34; width=&#34;595&#34; height=&#34;485&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/KyuhyunByun1/rds-aurora-postgresql-migration&#34; title=&#34;RDS에서 Aurora PostgreSQL Migration한 후기&#34; target=&#34;_blank&#34;&gt;RDS에서 Aurora PostgreSQL Migration한 후기&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;https://www.slideshare.net/KyuhyunByun1&#34; target=&#34;_blank&#34;&gt;Kyuhyun Byun&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;
&lt;h2 id=&#34;youtube&#34;&gt;Youtube&lt;/h2&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/34F5KY9gY_Y&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AWS Community Day 2020 소개 링크 &lt;a href=&#34;https://pages.awscloud.com/aws-community-day-online-2020.html&#34;&gt;https://pages.awscloud.com/aws-community-day-online-2020.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>MySQL에서 DB스키마 작성시 주의할 점들</title>
      <link>https://novemberde.github.io/post/2019/06/10/MySQL-Desgin-cheatsheet/</link>
      <pubDate>Mon, 10 Jun 2019 11:30:03 +0000</pubDate>
      
      <guid>https://novemberde.github.io/post/2019/06/10/MySQL-Desgin-cheatsheet/</guid>
      <description>&lt;p&gt;신규프로젝트를 진행할 경우 디비 스키마를 설계를 해야한다.
데이터의 타입부터 외래키 설정등 신경써야하는 부분들이 생각보다 자잘하게 있다.
이 경우에 주의해야하는 점들을 정리해보았다.
이 문서는 지속적으로 수정될 예정이다.&lt;/p&gt;
&lt;h2 id=&#34;datatype&#34;&gt;Datatype&lt;/h2&gt;
&lt;p&gt;MySQL에서 사용하는 데이터 타입은 다음과 같다.&lt;/p&gt;
&lt;h3 id=&#34;numeric-type&#34;&gt;Numeric Type&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;BIT[(M)] - A bit-value type. M indicates the number of bits per value, from 1 to 64. The default is 1 if M is omitted.&lt;/li&gt;
&lt;li&gt;TINYINT[(M)] [UNSIGNED] [ZEROFILL] - A very small integer. The signed range is -128 to 127. The unsigned range is 0 to 255.&lt;/li&gt;
&lt;li&gt;BOOL, BOOLEAN - These types are synonyms for TINYINT(1). A value of zero is considered false. Nonzero values are considered true. However, the values TRUE and FALSE are merely aliases for 1 and 0, respectively, as shown here.&lt;/li&gt;
&lt;li&gt;SMALLINT[(M)] [UNSIGNED] [ZEROFILL] - A small integer. The signed range is -32768 to 32767. The unsigned range is 0 to 65535.&lt;/li&gt;
&lt;li&gt;MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL] - A medium-sized integer. The signed range is -8388608 to 8388607. The unsigned range is 0 to 16777215.&lt;/li&gt;
&lt;li&gt;INT[(M)] [UNSIGNED] [ZEROFILL] - A normal-size integer. The signed range is -2147483648 to 2147483647. The unsigned range is 0 to 4294967295.&lt;/li&gt;
&lt;li&gt;INTEGER[(M)] [UNSIGNED] [ZEROFILL] - This type is a synonym for INT.&lt;/li&gt;
&lt;li&gt;BIGINT[(M)] [UNSIGNED] [ZEROFILL] - A large integer. The signed range is -9223372036854775808 to 9223372036854775807. The unsigned range is 0 to 18446744073709551615. SERIAL is an alias for BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Some things you should be aware of with respect to BIGINT columns:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Amazon Timestream 시계열 데이터 전용 DB 소개</title>
      <link>https://novemberde.github.io/post/2019/01/25/Timestream/</link>
      <pubDate>Fri, 25 Jan 2019 11:30:03 +0000</pubDate>
      
      <guid>https://novemberde.github.io/post/2019/01/25/Timestream/</guid>
      <description>&lt;p&gt;&amp;ldquo;시계열 데이터 전용 DB 소개&amp;quot;라는 주제로 2019년 1월 25일에 &lt;a href=&#34;https://pages.awscloud.com/aws-community-day-seoul-2019.html&#34;&gt;AWSKRUG re:Invent recap 행사&lt;/a&gt;에서 발표한 자료입니다.&lt;/p&gt;
&lt;h2 id=&#34;발표자료&#34;&gt;발표자료&lt;/h2&gt;
&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/F7GmlRSZZCQkKA&#34; width=&#34;595&#34; height=&#34;485&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/awskr/amazon-timestream-db&#34; title=&#34;Amazon Timestream 시계열 데이터 전용 DB 소개 :: 변규현 - AWS Community Day 2019&#34; target=&#34;_blank&#34;&gt;Amazon Timestream 시계열 데이터 전용 DB 소개 :: 변규현 - AWS Community Day 2019&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;https://www.slideshare.net/awskr&#34; target=&#34;_blank&#34;&gt;AWS Korea UserGroup (AWS한국사용자모임)&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slideshare.net/awskr/amazon-timestream-db&#34;&gt;https://www.slideshare.net/awskr/amazon-timestream-db&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pages.awscloud.com/aws-community-day-seoul-2019.html&#34;&gt;https://pages.awscloud.com/aws-community-day-seoul-2019.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>GraphDB 란?</title>
      <link>https://novemberde.github.io/post/2018/04/12/Neo4j/</link>
      <pubDate>Thu, 12 Apr 2018 11:30:03 +0000</pubDate>
      
      <guid>https://novemberde.github.io/post/2018/04/12/Neo4j/</guid>
      <description>&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;각 사용자들의 연관 관계 분석을 위하여 GraphDB를 도입하려한다.
시작하기에 앞서서 GraphDB에 대해서 이해가 필요했다. 다음에서 GraphDB의 기본 내용을 담았다.&lt;/p&gt;
&lt;h3 id=&#34;graph-database란&#34;&gt;Graph Database란?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;In computing, a graph database is a database that uses graph structures for semantic queries with nodes, edges and properties to represent and store data. A key concept of the system is the graph (or edge or relationship), which directly relates data items in the store. The relationships allow data in the store to be linked together directly, and in many cases retrieved with one operation.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AWS Lambda와 MySQL의 max connection 문제</title>
      <link>https://novemberde.github.io/post/2018/01/29/Mysql_maxConnection/</link>
      <pubDate>Mon, 29 Jan 2018 11:30:03 +0000</pubDate>
      
      <guid>https://novemberde.github.io/post/2018/01/29/Mysql_maxConnection/</guid>
      <description>&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;MySQL에서 Max Connection에 대해서 알아보려고 한다. AWS Lambda container가 지속적으로 생성될 때
Database가 감당할 수 있는 Max connection이 얼마인지 알아야 대응할 수 있기 때문이다.
만약 Lambda container가 MySQL이 감당할 수 없을 정도로 계속 생성된다면 Database에 connection이
일어나지 않게 되고, too many connections error가 발생하여 웹서버 역할을 해야하는 Lambda가 동작하지 않을 수 있다.
물론 MySQL에 접속하는 다른 Worker들도 동작하지 않는다.&lt;/p&gt;
&lt;p&gt;RDS를 사용하면 스케일 업이 될 때마다 Max connection 설정을 따로 하지 않더라도 알아서 늘어난다.
별다른 고민할 것 없이 Max connection이 생길 때마다 RDS를 scale up 해주어도 되겠지만 개발자이기 때문에
더 Graceful하게 문제를 해결해야한다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>다른 서버로 Mongodb 이전하기</title>
      <link>https://novemberde.github.io/post/2017/07/01/Mongodb_transport/</link>
      <pubDate>Sat, 01 Jul 2017 11:30:03 +0000</pubDate>
      
      <guid>https://novemberde.github.io/post/2017/07/01/Mongodb_transport/</guid>
      <description>&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;의뢰중에 호스팅 서버를 AWS로 옮겨달라는 요청이 있었다.
MongoDB서버를 옮기기 위해서 DB를 백업하고 SCP를 사용하여 백업한 정보를 해당 인스턴스로 보내 백업을 진행하였다.
몇몇 간단한 명령어를 통하면 DB의 backup정보를 통해 복구할 수 있다.
과정을 살펴보자.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;현재-db정보를-dump로-만들어-scp로-파일-전송하기&#34;&gt;현재 db정보를 dump로 만들어 SCP로 파일 전송하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;이전작업을 하기 전에 먼저 클라이언트에게 DB를 실제 서비스에서 분리하고 작업해야된다고 하였다.&lt;/p&gt;
&lt;p&gt;설정정보를 바꾼다면 DB를 재가동 해야하는 이유도 있었으며, mongodb dump파일을 생성한 시점부터는 추가되는 데이터가 없어야 하기 때문이다.&lt;/p&gt;
&lt;p&gt;먼저 외부와의 접속을 차단하고 mongodump파일을 생성해 보자.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
