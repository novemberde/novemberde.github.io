<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Javascript on Novemberde&#39;s Blog</title>
    <link>https://novemberde.github.io/tags/javascript/</link>
    <description>Recent content in Javascript on Novemberde&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Tue, 19 Dec 2017 11:30:03 +0000</lastBuildDate><atom:link href="https://novemberde.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android Webview에서 Javascript에러로 인해 뷰가 안나올 경우</title>
      <link>https://novemberde.github.io/post/2017/12/19/Android-Webview/</link>
      <pubDate>Tue, 19 Dec 2017 11:30:03 +0000</pubDate>
      
      <guid>https://novemberde.github.io/post/2017/12/19/Android-Webview/</guid>
      <description>&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Javascript WebView로 특정 URL의 컨텐츠를 보여주는데 화면이 나오지 않았다.
현상은 배경색까지 나타나고 DOM이 뿌려지지 않는 문제였다.
Webview에서 Unexpected token의 에러를 뿜었기 때문에 쉽게 Javascript 관련 오류라는 것을 알 수 있었고
Javascript error를 무시할 수 있도록 하는 메서드를 실행하였다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;webview의-setting에-setdomstorageenabledtrue를-추가하기&#34;&gt;Webview의 Setting에 setDomStorageEnabled(true)를 추가하기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;기존의 코드는 다음과 같다&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyWebView&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; AppCompatActivity {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; WebView webView;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onCreate&lt;/span&gt;(Bundle savedStateInstance){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onCreate&lt;/span&gt;(savedStateInstance);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        setContentView(R.&lt;span style=&#34;color:#a6e22e&#34;&gt;layout&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;webview&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        webView &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ( WebView )findViewById( R.&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;webview&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        webView.&lt;span style=&#34;color:#a6e22e&#34;&gt;getSettings&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;setRenderPriority&lt;/span&gt;(WebSettings.&lt;span style=&#34;color:#a6e22e&#34;&gt;RenderPriority&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HIGH&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        webView.&lt;span style=&#34;color:#a6e22e&#34;&gt;setWebViewClient&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; WebViewClient());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        webView.&lt;span style=&#34;color:#a6e22e&#34;&gt;setWebChromeClient&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; WebChromeClient());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        webView.&lt;span style=&#34;color:#a6e22e&#34;&gt;setNetworkAvailable&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        webView.&lt;span style=&#34;color:#a6e22e&#34;&gt;getSettings&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;setJavaScriptEnabled&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        webView.&lt;span style=&#34;color:#a6e22e&#34;&gt;loadUrl&lt;/span&gt;(url);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;변경한 코드는 다음과 같다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Javascript에서 Closure와 Constructor</title>
      <link>https://novemberde.github.io/post/2017/04/16/Closure_0/</link>
      <pubDate>Sun, 16 Apr 2017 11:30:03 +0000</pubDate>
      
      <guid>https://novemberde.github.io/post/2017/04/16/Closure_0/</guid>
      <description>&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;node js나 web ui를 다루기 위해 javascript를 사용하면 closure를 사용할 것이다. constructor로 객체를 생성하지 않고 왜 closure를 사용하는지 살펴보자.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;constructor와-closure의-성능차이&#34;&gt;Constructor와 Closure의 성능차이&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;샘플코드는 아래와 같다. 성능 결과값을 보면 거의 2배의 차이가 나는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;이러한 차이는 node 서버를 사용할 경우 더욱 두드러지게 체감할 것이다.&lt;/p&gt;
&lt;p&gt;constructor를 사용하는 경우 javascript 객체가 반드시 가져야할 함수들을 상속받기 때문에 속도차이가 나타나는 것이다. 하지만 front에서는 클라이언트가 메모리를 가지기 때문에 크게 우려하지 않아도 된다.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
